/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
/*
# FINAL EKF: WEIGHTED SENSOR FUSION
# Approach:
# 1. Calculate Rotation from Encoders (High drift on turns)
# 2. Calculate Rotation from Gyro (Drift over time, precise on turns)
# 3. Fuse them based on Variance (Confidence)
# 4. Use RealSense for absolute Position Correction
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
#include <deque>
#include <numeric>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class MovingAverage {
    std::deque<double> _window;
    size_t _size;
    double _sum = 0.0;
public:
    MovingAverage(size_t size = 10) : _size(size), _sum(0.0) {}
    
    void resize(size_t new_size) { _size = new_size; _window.clear(); _sum = 0.0; }

    double update(double val) {
        _window.push_back(val);
        _sum += val;
        if (_window.size() > _size){
          double removed = _window.front();
          _sum -= removed;
          _window.pop_front();
        } 

        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }
};

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato interno del Robot (Pose)
    struct State {
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0; // Radianti

        double Pxx = 0.01;  // Cov X
        double Pyy = 0.01;  // Cov Y
        double Ptt = 0.01; // Cov Theta
    } _state;

    struct StateRaw{
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0;
    } _state_enc_only;

    struct DebugState {
        double theta_enc_only = 0.0;
        double theta_imu_only = 0.0;
    } _debug;

    struct DebugSlip {
        double enc_accel = 0.0;
        double imu_accel = 0.0;
        bool is_slipping = false; 
    } _debug_slip;


    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] (Esempio, da calibrare)
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;            // B [m] No baseline needed with gyro
        double ticks_per_rev = 4096.0;     // Risoluzione Encoder

        // kalman tuning
        double sigma_v = 0.005;  // vel uncertainty encoder
        double sigma_w = 0.002; // gyro uncertainty
        double sigma_rs_pos = 0.8;  // RealSense uncertainty
        double sigma_rs_ang = 0.5;  // RealSense angle uncertainty

        double sigma_enc_lin = 0.005; // Errore encoder lineare (m/s)
        double sigma_enc_rot = 0.05;  // Errore encoder rotazionale (rad/s)
        double sigma_gyro    = 0.002; // Errore giroscopio (rad/s)

        double slip_accel_thresh = 0.5; // Soglia accelerazione per slip
        double static_thresh = 0.05;    // Soglia per considerare ferm
        bool enable_slip_check = true;
        double slip_accel_ratio = 1.5;   // Rapporto accel a_enc / a_imu

        int filter_window_rs = 10;
        int filter_window_imu = 5;  
        int filter_window_acc = 10; // Finestra per accelerometro    

        double rs_global_rotation = 3.14;
        double cam_offset_x = 0.80;
        double cam_offset_y = 0.0;
        bool invert_gyro = true;

        // Parametri Offset IMU (Lever Arm) nel frame del Robot
        double imu_offset_x = 0.70;
        double imu_offset_y = 0.20;
        double imu_offset_z = 0.00;
        
    } _conf;

    // BUffer data:
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;

    // Encoder memory
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;
    bool _has_new_encoder_data = false;

    // Moving Average Filters
    MovingAverage _filter_rs_x;
    MovingAverage _filter_rs_y;
    MovingAverage _filter_rs_theta;

    //MovingAverage _filter_enc_v; // Rimosso, uso filtro esponenziale inline
    MovingAverage _filter_enc_a; // filtro ibrido per accelerazione encoder

    string _last_agent_id = "";
    double _last_timecode = 0.0;
    double _prev_time = 0.0;

    // IMU Data
    MovingAverage _filter_gyro;
    MovingAverage _filter_accel; // Filtro per Accel X
    double _current_gyro_z = 0.0;
    double _current_accel_x = 0.0;
    bool _has_gyro = false;
    bool _has_imu = false;

    double _bias_accel_x = 0.0;
    int _calibration_samples = 0;
    bool _bias_computed = false;
    const int CALIBRATION_LIMIT = 400;
    
    double _imu_accel_smooth_ema1 = 0.0;
    double _imu_accel_smooth_ema2 = 0.0;

    // Mem per calcolare derivata angolare
    double _prev_gyro_x = 0.0;
    double _prev_gyro_y = 0.0;
    double _prev_gyro_z = 0.0;
    double _prev_imu_timecode = 0.0;
    bool _first_imu_frame = true;

    double _v_enc_smooth = 0.0;
    double _a_enc_smooth = 0.0;

    double _prev_v_enc = 0.0; // Velocità precedente (per calcolo accel)

    // Memory for anti-freeze check
    double _prev_raw_rs_x = -9999.0;
    double _prev_raw_rs_y = -9999.0;

    // Correction data RealSense
    double _rs_x = 0.0;
    double _rs_y = 0.0;
    double _rs_theta = 0.0;
    bool _has_rs_update = false;

   

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "EKF + Raw Encoder + anti-slip logic"},
        };
  }

  Odometry_filterPlugin() : 
    _filter_rs_x(10), 
    _filter_rs_y(10), 
    _filter_rs_theta(10), 
    _filter_gyro(5), 
    _filter_accel(15),
    //_filter_enc_v(10),
    _filter_enc_a(15)
    {}
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {

    // Timecode
    double now = 0.0;
    if(in.contains("message") && in["message"].contains("timecode")){
        now = in["message"]["timecode"].get<double>();
    } else if (in.contains("/message/timecode")) {
        now = in["/message/timecode"].get<double>();
    }
    if(now > 0) _last_timecode = now;

    // Encoders
    if (in.contains("/message/encoders/left") || (in.contains("message") && in["message"].contains("encoders"))) {
        if (in.contains("/message/encoders/left")) {
            _incoming_ticks_l = (long)in["/message/encoders/left"].get<double>();
            _incoming_ticks_r = (long)in["/message/encoders/right"].get<double>();
        } else {
            _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
            _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
        }

        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _prev_time = _last_timecode;
            _initialized = true;
        } else {
            _has_new_encoder_data = true;
        }
    }
    
    // --- 3. IMU (NUOVO FORMATO: Array Piatto) ---
    if (in.contains("message")){
      //Variabili temporanee
      double gx_body = 0.0, gy_body = 0.0, gz_body = 0.0;
      double ax_body = 0.0, ay_body = 0.0, az_body = 0.0;
      bool gyro_ready = false;
      bool accel_ready = false;

      //Gyro
      if (in["message"].contains("gyro")) {
        auto& gyro = in["message"]["gyro"];
        if (gyro.is_array() && gyro.size() >= 3) {
          double raw_gx = gyro[0].get<double>();
          double raw_gy = gyro[1].get<double>();
          double raw_gz = gyro[2].get<double>();
          
          // Applicazione matrice di rotazione R = Rx(180) * Rz(-90)
          // X_new = y_old, Y_new = x_old, Z_new = -z_old
          gx_body = raw_gy;
          gy_body = raw_gx;
          gz_body = -raw_gz;

          gyro_ready = true;
        }
      }

      // Accel
      if (in["message"].contains("accel")) {
        auto& accel = in["message"]["accel"];
        if (accel.is_array() && accel.size() >= 1) {
          double raw_ax = accel[0].get<double>() * 9.80665;
          double raw_ay = accel[1].get<double>() * 9.80665;
          double raw_az = accel[2].get<double>() * 9.80665;
          
          ax_body = raw_ay;
          ay_body = raw_ax;
          az_body = -raw_az;

          accel_ready = true;
        }
      }

      if (gyro_ready && accel_ready) {

        double dt_imu = now - _prev_imu_timecode;
        if(dt_imu <= 0.0) dt_imu = 1e-6; // Prevenzione divisione per zero

        if(!_first_imu_frame){
          // Calcolo Accelerazione Angolare (Alpha = dOmega/dt)
          double alpha_x = (gx_body - _prev_gyro_x) / dt_imu;
          double alpha_y = (gy_body - _prev_gyro_y) / dt_imu;
          double alpha_z = (gz_body - _prev_gyro_z) / dt_imu;

          // Vettore Offset (lever arm)
          double rx = _conf.imu_offset_x;
          double ry = _conf.imu_offset_y;
          double rz = _conf.imu_offset_z;

          // Termine tangenziale (Alpha x R)
          double tan_x = alpha_y * rz - gz_body * ry;
          double tan_y = gz_body * rx - alpha_x * rz;
          double tan_z = alpha_x * ry - alpha_y * rx;

          // Termine centripeto (Omega x (Omega x R))
          // Omega x R
          double oxr_x = gy_body * rz - gz_body * ry;
          double oxr_y = gz_body * rx - gx_body * rz;
          double oxr_z = gx_body * ry - gy_body * rx;
          // Omega x (Omega x R)
          double cent_x = gy_body * oxr_z - gz_body * oxr_y;
          double cent_y = gz_body * oxr_x - gx_body * oxr_z;
          double cent_z = gx_body * oxr_y - gy_body * oxr_x;
          
          // Correzione finale
          // a_body = a_measured - a_tangential - a_centripetal
          double ax_corrected = ax_body - tan_x - cent_x;

          // Aggiorna filtro
          double val_gyro_z = _conf.invert_gyro ? -gz_body : gz_body;
          _current_gyro_z = _filter_gyro.update(val_gyro_z);

          // Accelerometro X
          if(!_bias_computed){
            if(_calibration_samples < CALIBRATION_LIMIT){
              _bias_accel_x += ax_corrected;
              _calibration_samples++;
              _current_accel_x = 0.0;
            } else {
              _bias_accel_x /= (double)CALIBRATION_LIMIT;
              _bias_computed = true;
              std::cout << "IMU Calibrated with lever arm. Bias X: " << _bias_accel_x << std::endl;
            }
          } else {
            double clean_accel = ax_corrected - _bias_accel_x;
            _current_accel_x = _filter_accel.update(clean_accel);
        }


      }
      // aggiorna storico per la derivata
        _prev_gyro_x = gx_body;
        _prev_gyro_y = gy_body;
        _prev_gyro_z = gz_body;
        _prev_imu_timecode = now;
        _first_imu_frame = false;
        _has_gyro = true;
        _has_imu = true;
      }   
    }

    // RealSense
    double raw_rs_x = 0.0, raw_rs_y = 0.0, raw_rs_theta = 0.0;
    bool rs_found = false;

    if (in.contains("message") && in["message"].contains("pose")) {
      auto& p = in["message"]["pose"];
        // Position
      if (p.contains("position") && p["position"].is_array() && p["position"].size() > 0) {
        // Check if it's [[x,y,z]] or [x,y,z]
        if (p["position"][0].is_array()) {
          raw_rs_x = p["position"][0][0].get<double>();
          raw_rs_y = p["position"][0][1].get<double>();
        } else {
          raw_rs_x = p["position"][0].get<double>();
          raw_rs_y = p["position"][1].get<double>();
        }

        // Angle (Handle nested arrays)
      if (p.contains("attitude")) {
        if(p["attitude"][0].is_array()){
        raw_rs_theta = p["attitude"][0][2].get<double>();
        } else {
        raw_rs_theta = p["attitude"][2].get<double>();
        //else raw_rs_theta = att.get<double>(); // If scalar
        }
      }
        rs_found = true;
      }
      
      
      
    }


    // Anti-freeze check & filtering
    if (rs_found) {

      // Sistema sinistrorso
      raw_rs_y = -raw_rs_y;
      raw_rs_theta = -raw_rs_theta;

      double rot = _conf.rs_global_rotation;
      double x_new = (raw_rs_x * cos(rot) - raw_rs_y * sin(rot));
      double y_new = (raw_rs_x * sin(rot) + raw_rs_y * cos(rot));

      raw_rs_x = x_new;
      raw_rs_y = y_new;
      raw_rs_theta += rot;

       if(_first_rs_frame){
      _rs_theta_unwrapped = raw_rs_theta;
      _prev_rs_theta_raw = raw_rs_theta;
      _first_rs_frame = false;
      }

      double delta_theta_rs = raw_rs_theta - _prev_rs_theta_raw;

      while (delta_theta_rs > M_PI) delta_theta_rs -= 2.0 * M_PI;
      while (delta_theta_rs < -M_PI) delta_theta_rs += 2.0 * M_PI; 

      _rs_theta_unwrapped += delta_theta_rs;
      _prev_rs_theta_raw = raw_rs_theta;
      

      double dist = sqrt(pow(raw_rs_x - _prev_raw_rs_x, 2) + pow(raw_rs_y - _prev_raw_rs_y, 2));
      if (dist > 0.0001 || abs(delta_theta_rs) > 0.001) { // Not stuck
        _rs_x = _filter_rs_x.update(raw_rs_x);
        _rs_y = _filter_rs_y.update(raw_rs_y);

        double filtered_unwrapped = _filter_rs_theta.update(_rs_theta_unwrapped);
        _rs_theta = filtered_unwrapped;
        while (_rs_theta > M_PI) _rs_theta -= 2.0 * M_PI;
        while (_rs_theta < -M_PI) _rs_theta += 2.0 * M_PI;
                
        _has_rs_update = true;
        _prev_raw_rs_x = raw_rs_x;
        _prev_raw_rs_y = raw_rs_y;
      }
    }

    if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

  } catch (...){ return return_type::error; }
    return return_type::success;
  }
    


  // EKF Process
    return_type process(json &out) override {
        out.clear();

        // if no new data, skip
        if (!_has_new_encoder_data) {
            return return_type::success; // O warning,
        }

        double current_dt = _last_timecode - _prev_time;
        if(current_dt <= 0.01) return return_type::success; // Evita calcoli inutili

        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_encoder_data = false;

        double dt = current_dt;
        if (dt <= 1e-6) dt = 1e-6; // Prevenzione divisione per zero
        _prev_time = _last_timecode;

        // --- PREDICTION (Usa Gyroscope!) ---
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;
        double ds = (d_right + d_left) / 2.0;
        double ds_only_enc = ds;

        // calcolo velocità e accelerazione encoder
        double v_enc_raw = ds / dt;

        //_v_enc_smooth = _filter_enc_v.update(v_enc_raw); //Moving average logic


        double alpha_v = 0.10;
        _v_enc_smooth = (alpha_v * v_enc_raw) + ((1.0 - alpha_v) * _v_enc_smooth); // Low pass filter exponential

        double a_enc_raw = (_v_enc_smooth - _prev_v_enc) / dt;
        //_a_enc_smooth = _filter_enc_a.update(a_enc_raw); //Moving average logic 
        

        double alpha_a = 0.20;
        _a_enc_smooth = (alpha_a * a_enc_raw) + ((1.0 - alpha_a) * _a_enc_smooth); // Low pass filter exponential
        double a_enc_sma = _filter_enc_a.update(_a_enc_smooth); // Moving average filter

        // manipolazione valori imu per inserire ritardo artificiale simile a encoder
        _imu_accel_smooth_ema1 = (alpha_v * _current_accel_x) + ((1.0 - alpha_v) * _imu_accel_smooth_ema1);
        _imu_accel_smooth_ema2 = (alpha_a * _imu_accel_smooth_ema1) + ((1.0 - alpha_a) * _imu_accel_smooth_ema2);
        double a_imu_final = _imu_accel_smooth_ema2;

        _prev_v_enc = _v_enc_smooth;


        bool is_slipping = false;

        double min_imu_accel_for_correction = 0.05;

        if(_conf.enable_slip_check && _bias_computed){
            // 2. Acceleration Mismatch (Burnout Check)
            // Se gli encoder dicono "Partenza a razzo" (alta accel)
            // Ma l'IMU dice "Movimento blando"
          if (abs(a_enc_sma) > abs(a_imu_final) && abs(a_imu_final) > min_imu_accel_for_correction) {
            is_slipping = true; // Rilevato slip
            double ratio = abs(a_enc_sma) / abs(a_imu_final);

            //if(ratio > 10) ratio = 10.0; // Limite massimo

            ds = ds / ratio;

          }
          
        }

        _debug_slip.enc_accel = a_enc_sma;
        _debug_slip.imu_accel = a_imu_final;
        _debug_slip.is_slipping = is_slipping;

        
        // rotation encoder
        double d_theta_enc = (d_right - d_left) / _conf.baseline;
        // Rotation gyro
        double d_theta_gyro = 0.0;
        if(_has_gyro){
            d_theta_gyro = _current_gyro_z * dt;
        }

        // Update raw encoder only state
        double avg_theta_enc = _state_enc_only.theta + d_theta_enc / 2.0;
        _state_enc_only.x += ds_only_enc * cos(avg_theta_enc);
        _state_enc_only.y += ds_only_enc * sin(avg_theta_enc);
        _state_enc_only.theta += d_theta_enc;


        double var_enc = _conf.sigma_enc_rot * _conf.sigma_enc_rot;
        double var_gyro = _conf.sigma_gyro * _conf.sigma_gyro;

        double weight_gyro = 0.0;
        double weight_enc = 1.0;
        if(_has_gyro){
            weight_gyro = var_enc / (var_enc + var_gyro);
            weight_enc = var_gyro / (var_enc + var_gyro);
        }

        double d_theta_fused = (d_theta_gyro * weight_gyro) + (d_theta_enc * weight_enc);

        double avg_theta = _state.theta + d_theta_fused / 2.0;
        

        // Update state
        _state.x += ds * cos(avg_theta);
        _state.y += ds * sin(avg_theta);
        _state.theta += d_theta_fused;

        // Normalization Theta
        while (_state.theta > M_PI) _state.theta -= 2.0 * M_PI;
        while (_state.theta < -M_PI) _state.theta += 2.0 * M_PI;
        
        _state.Pxx += _conf.sigma_enc_lin * abs(ds);
        _state.Pyy += _conf.sigma_enc_lin * abs(ds);

        double combined_sigma = sqrt(pow(_conf.sigma_gyro * weight_gyro, 2) + pow(_conf.sigma_enc_rot * weight_enc, 2));
        _state.Ptt += combined_sigma * abs(d_theta_fused);

        double sigma_curr = is_slipping ? 1.0 : _conf.sigma_v; // Aumenta incertezza se slittamento
        _state.Pxx += sigma_curr * abs(ds);
        _state.Pyy += sigma_curr * abs(ds);
        _state.Ptt += _conf.sigma_w * abs(d_theta_fused);

        // Correction
        if(_has_rs_update){

          double est_sensor_x = _state.x + cos(_state.theta) * _conf.cam_offset_x - sin(_state.theta) * _conf.cam_offset_y;
          double est_sensor_y = _state.y + sin(_state.theta) * _conf.cam_offset_x + cos(_state.theta) * _conf.cam_offset_y;
          // --- CORRECTION ---
          double innov_x = _rs_x - est_sensor_x;
          double innov_y = _rs_y - est_sensor_y;
            
          // Position correction
          double K_x = _state.Pxx / (_state.Pxx + _conf.sigma_rs_pos);
          double K_y = _state.Pyy / (_state.Pyy + _conf.sigma_rs_pos);

          _state.x += K_x * innov_x;
          _state.y += K_y * innov_y;

          _state.Pxx *= (1.0 - K_x);
          _state.Pyy *= (1.0 - K_y);

          // Angle correction
          double y_theta = _rs_theta - _state.theta;
          while (y_theta > M_PI) y_theta -= 2.0 * M_PI;
          while (y_theta < -M_PI) y_theta += 2.0 * M_PI;

          double K_t = _state.Ptt / (_state.Ptt + _conf.sigma_rs_ang);

          _state.theta += K_t * y_theta;
          _state.Ptt *= (1.0 - K_t);

          _has_rs_update = false;
        }

        _debug.theta_enc_only = d_theta_enc;
        _debug.theta_imu_only = d_theta_gyro;

        // OUTPUT
        out["pose"]["position"]["x"] = _state.x;
        out["pose"]["position"]["y"] = _state.y;
        out["pose"]["position"]["z"] = 0.0;
        out["pose"]["orientation"]["yaw"] = _state.theta;

        std::vector<double> pos_vec = {_state.x, _state.y, 0.0};
        out["pose_vector"] = pos_vec;

        out["debug"]["raw_encoder_only"] = std::vector<double>{_state_enc_only.x, _state_enc_only.y, 0.0};

        out["debug"]["theta_enc"] = _debug.theta_enc_only;
        out["debug"]["theta_imu"] = _debug.theta_imu_only;
        //out["debug"]["theta_fused"] = _state.theta;

        out["debug"]["accel_enc"] = _debug_slip.enc_accel;
        out["debug"]["accel_imu"] = _debug_slip.imu_accel;
        out["debug"]["is_slipping"] = _debug_slip.is_slipping ? 1.0 : 0.0;

        out["debug"]["angles"]["rs_raw"] = _prev_rs_theta_raw;
        out["debug"]["angles"]["rs_unwrapped"] = _rs_theta_unwrapped;
        out["debug"]["angles"]["fused"] = _state.theta;
        out["debug"]["angles"]["enc_only"] = _state_enc_only.theta;

        double theta_rs = _rs_theta_unwrapped;

        double rs_robot_x = _rs_x - (cos(theta_rs) * _conf.cam_offset_x - sin(theta_rs) * _conf.cam_offset_y);
        double rs_robot_y = _rs_y - (sin(theta_rs) * _conf.cam_offset_x + cos(theta_rs) * _conf.cam_offset_y);

        out["debug"]["rs_center"] = std::vector<double>{rs_robot_x, rs_robot_y, 0.0};
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timecode;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];

    if(p.contains("sigma_enc_lin")) _conf.sigma_enc_lin = p["sigma_enc_lin"];
    if(p.contains("sigma_enc_rot")) _conf.sigma_enc_rot = p["sigma_enc_rot"];
    if(p.contains("sigma_gyro")) _conf.sigma_gyro = p["sigma_gyro"];
    if(p.contains("sigma_rs_pos")) _conf.sigma_rs_pos = p["sigma_rs_pos"];
    if(p.contains("sigma_rs_ang")) _conf.sigma_rs_ang = p["sigma_rs_ang"];

    if (p.contains("filter_window_rs")) {
            _conf.filter_window_rs = p["filter_window_rs"];
            _filter_rs_x.resize(_conf.filter_window_rs);
            _filter_rs_y.resize(_conf.filter_window_rs);
    }

    if (p.contains("filter_window_imu")) {
      _conf.filter_window_imu = p["filter_window_imu"];
      _filter_gyro.resize(_conf.filter_window_imu);
      _filter_accel.resize(_conf.filter_window_acc);
    }

    

    if( p.contains("cam_offset_x")) _conf.cam_offset_x = p["cam_offset_x"];
    if( p.contains("cam_offset_y")) _conf.cam_offset_y = p["cam_offset_y"];
    if( p.contains("rs_global_rotation")) _conf.rs_global_rotation = p["rs_global_rotation"];
    if( p.contains("invert_gyro")) _conf.invert_gyro = p["invert_gyro"];

    if (p.contains("slip_accel_thresh")) _conf.slip_accel_thresh = p["slip_accel_thresh"];
    if (p.contains("static_thresh")) _conf.static_thresh = p["static_thresh"];
    if (p.contains("enable_slip_check")) _conf.enable_slip_check = p["enable_slip_check"];
    if(p.contains("slip_accel_ratio")) _conf.slip_accel_ratio = p["slip_accel_ratio"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    _state = {0, 0, 0, 0.01, 0.01, 0.01};
    _state_enc_only = {0,0,0}; // Reset stato raw
    _debug = {0,0};
    _initialized = false;
    _prev_raw_rs_x = -9999.0;
    _prev_raw_rs_y = -9999.0;

    _first_rs_frame = true;
    _rs_theta_unwrapped = 0.0;
    _prev_rs_theta_raw = 0.0;
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  double _prev_rs_theta_raw = 0.0;
  double _rs_theta_unwrapped = 0.0;
  bool _first_rs_frame = true;
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    in["encoders"]["left"] = 100;
    in["encoders"]["right"] = 100;
    
    f.load_data(in);
    f.process(out);

    std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}