/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
/*
# FINAL EKF: WEIGHTED SENSOR FUSION
# Approach:
# 1. Calculate Rotation from Encoders (High drift on turns)
# 2. Calculate Rotation from Gyro (Drift over time, precise on turns)
# 3. Fuse them based on Variance (Confidence)
# 4. Use RealSense for absolute Position Correction
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
#include <deque>
#include <numeric>
#include <Eigen/Dense>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace Eigen;
using namespace std;
using json = nlohmann::json;

// Normalizzazione angoli
double normalize_angle(double angle) {
    while (angle > M_PI) angle -= 2.0 * M_PI;
    while (angle < -M_PI) angle += 2.0 * M_PI;
    return angle;
}

//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif


class MovingAverage {
    std::deque<double> _window;
    size_t _size;
    double _sum = 0.0;
public:
    MovingAverage(size_t size = 10) : _size(size), _sum(0.0) {}
    
    void resize(size_t new_size) { _size = new_size; _window.clear(); _sum = 0.0; }

    void clear() { _window.clear(); _sum = 0.0; }

    double update(double val) {
        _window.push_back(val);
        _sum += val;
        if (_window.size() > _size){
          double removed = _window.front();
          _sum -= removed;
          _window.pop_front();
        } 

        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }
};


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato con eigen
  struct State{
    Vector3d x; // Stato: [x, y, theta]
    Matrix3d P; // Covarianza 3x3 
  };

    State _state;
    State _state_partial; // EKF parziale (Solo encoder + RS)

    struct StateRaw{
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0;
    } _state_enc_only;

    struct DebugState {
        double theta_enc_only = 0.0;
        double theta_imu_only = 0.0;
    } _debug;

    struct DebugSlip {
        double enc_accel = 0.0;
        double imu_accel = 0.0;
        double enc_vel = 0.0;
        double imu_vel = 0.0;
        bool is_slipping = false; 
    } _debug_slip;

    struct DebugAngle{
      double angle_enc = 0.0;
      double angle_imu = 0.0;
      double avg_imu_enc = 0.0;
    } _debug_angle;

//MOST VALUES ARE DECLARED HERE, BUT SOME ARE REDEFINED IN THE MADS.INI FILE
    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] (Esempio, da calibrare)
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;          // B [m] No baseline needed with gyro
        double ticks_per_rev = 4096;     // Risoluzione Encoder

        // kalman tuning
        double sigma_v = 0.05;  // vel uncertainty encoder
        double sigma_w = 0.05; // gyro uncertainty
        double sigma_rs_pos = 0.05;  // RealSense uncertainty
        double sigma_rs_ang = 0.05;  // RealSense angle uncertainty
        double sigma_acc = 0.065; // accelerometer uncertainty
        double sigma_enc_lin = 0.05; // Errore encoder lineare (m/s)
        double sigma_enc_rot = 0.2;  // Errore encoder rotazionale (rad/s)
        double sigma_gyro = 0.002; // Errore giroscopio (rad/s)

        //double slip_accel_thresh = 0.5; // Soglia accelerazione per slip
        double min_imu_accel_for_correction = 0.05;    // Soglia per considerare ferm
        bool enable_slip_check = false;
        double slip_accel_ratio = 1.5;   // Rapporto accel a_enc / a_imu
        double alpha_a = 0.15;
        double alpha_v = 0.10;
        double slip_ratio = 1.5;

        int filter_window_rs = 5;
        int filter_window_imu = 10;  
        int filter_window_enc = 10; // Finestra per accelerometro    

        double rs_global_rotation;
        double cam_offset_x;
        double cam_offset_y;
        //bool invert_gyro = true;

        bool aruco_is_walker_center; //param to know if aruco is at walker center or camera center

        // Parametri Offset IMU (Lever Arm) nel frame del Robot
        double imu_offset_x = 0.70;
        double imu_offset_y = 0.20;
        double imu_offset_z = 0.00;

        bool calibration_active = false;
        double gyro_scaling = 1.005964613;//1798.690728/1788.025845; // scaling factor from calibration
        
    } _conf;

    // BUffer data:
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;

    // Encoder memory
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;
    bool _has_new_encoder_data = false;
    double _prev_ds = 0.0;

    // Moving Average Filters
    MovingAverage _filter_rs_x; //Non uso
    MovingAverage _filter_rs_y; //Non uso
    MovingAverage _filter_rs_theta; //Non uso

    //MovingAverage _filter_enc_v; // Rimosso, uso filtro esponenziale inline
    MovingAverage _filter_enc_a; // filtro ibrido per accelerazione encoder

    string _last_agent_id = "";
    double _last_timecode = 0.0;
    double _prev_time = 0.0;
    double _last_timecode_enc = 0.0;

    // IMU Data
    MovingAverage _filter_gyro;
    MovingAverage _filter_accel; // Filtro per Accel X
    double _current_gyro_z = 0.0;
    double _current_accel_x = 0.0;

    double _bias_accel_x = 0.0;
    double _bias_gyro_z = 0.0;
    int _calibration_samples = 0;
    bool _bias_computed = false;
    const int CALIBRATION_LIMIT = 400;
    
    double _imu_accel_smooth_ema1 = 0.0;
    double _imu_accel_smooth_ema2 = 0.0;

    

    // Mem per calcolare derivata angolare
    double _prev_gyro_x = 0.0;
    double _prev_gyro_y = 0.0;
    double _prev_gyro_z = 0.0;
    double _prev_imu_timecode = 0.0;
    bool _first_imu_frame = true;

    double _v_enc_smooth = 0.0;
    double _a_enc_smooth = 0.0;
    double _prev_v_enc = 0.0; 

    // Memory for anti-freeze check
    double _prev_raw_rs_x = -9999.0;
    double _prev_raw_rs_y = -9999.0;
    double _ekf_theta_rs = 0.0;
    double raw_rs_x = 0.0, raw_rs_y = 0.0, raw_rs_theta = 0.0;

    // Correction data RealSense
    double _rs_x = 0.0;
    double _rs_y = 0.0;
    double _rs_theta = 0.0;
    bool _has_rs_update = false;

    // Variabili interne per debug e calcolo velocità
    double _prev_input_rs_theta = 0.0; 

    //htc position
    double _htc_x = 0.0;
    double _htc_y = 0.0;
    double _htc_angle = 0.0;

    std::vector<double> _calib_acc_x;
    std::vector<double> _calib_acc_y;
    std::vector<double> _calib_gyro_z;
    std::vector<double> _calib_rs_x;
    std::vector<double> _calib_rs_y;
    std::vector<double> _calib_rs_theta;

   

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "EKF + Raw Encoder + anti-slip logic + ARUCO"},
        };
  }

  Odometry_filterPlugin() : 
    _filter_rs_x(_conf.filter_window_rs), //Should not be too big
    _filter_rs_y(_conf.filter_window_rs), //Should not be too big
    _filter_rs_theta(_conf.filter_window_rs), //Should not be too big
    _filter_gyro(_conf.filter_window_imu), //Aumento?
    _filter_accel(_conf.filter_window_imu),//Aumento?
    //_filter_enc_v(10),
    _filter_enc_a(_conf.filter_window_enc)//Aumento?
    {}
  
  // -- Funzione di predizione EKF
void ekf_predict(State &s, double ds, double d_theta, double sigma_ds, double sigma_dth) {
  double theta = s.x(2);
  double cos_th = cos(theta + d_theta/2.0); // Half-angle approx per Runge-Kutta
  double sin_th = sin(theta + d_theta/2.0);

  // Predizione Stato
  s.x(0) += ds * cos_th;
  s.x(1) += ds * sin_th;
  s.x(2) += d_theta;
  s.x(2) = normalize_angle(s.x(2));

  // Jacobiano F (3x3)
  Matrix3d F = Matrix3d::Identity();
  F(0, 2) = -ds * sin_th;
  F(1, 2) =  ds * cos_th;
  
  // Matrice Rumore di Processo Q
  Matrix3d Q = Matrix3d::Zero();
  double var_ds = sigma_ds * sigma_ds;
  double var_dth = sigma_dth * sigma_dth;

  // Proiezione rumore
  Q(0, 0) = var_ds * cos_th * cos_th + 1e-9;
  Q(1, 1) = var_ds * sin_th * sin_th + 1e-9;
  Q(2, 2) = var_dth + 1e-9;

  // PREDIZIONE COVARIANZA: P = F * P * F^T + Q
  s.P = (F * s.P * F.transpose()) + Q;

}

// calculate std deviation
  double std_dev(const std::vector<double>& data) {
    if ( data.size() < 2) return 0.0;
    double sum = 0.0, mean, standardDeviation = 0.0;
    for (double num : data) sum += num;
    mean = sum / data.size();
    for(double num : data) standardDeviation += pow(num - mean, 2);
    return sqrt(standardDeviation / data.size());
  }

// --- FUNZIONE DI CORREZIONE EKF (UPDATE) ---
void ekf_update(State &s, const Vector3d &z, const Matrix3d &R) {
  // Z = Misura [x, y, theta]
  // R Covarianza Misura

  Vector3d y = z - s.x; 

  y(2) = normalize_angle(y(2));

  Matrix3d H = Matrix3d::Identity();
  Matrix3d S = H * s.P * H.transpose() + R;
  Matrix3d K = s.P * H.transpose() * S.inverse();

  s.x = s.x + K * y;
  s.x(2) = normalize_angle(s.x(2));

  Matrix3d I = Matrix3d::Identity();
  s.P = (I - K * H) * s.P;
}
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {

    // Timecode
    if(in["message"].contains("timecode")){
        _last_timecode = in["message"]["timecode"].get<double>();
    } 

    // Encoders
    if (in["agent_id"].get<string>() == "encoders_source") {
        
            _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
            _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
        

        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _prev_time = _last_timecode;
            _last_timecode_enc = _last_timecode;
            _initialized = true;
        } else {
            _has_new_encoder_data = true;
            _last_timecode_enc = _last_timecode;
        }
    }

    // HTC
    if(in["agent_id"].get<string>() == "pose_htc_source") {
        try{
          if(in["message"]["pose"].contains("position")){
            auto& pos = in["message"]["pose"]["position"];

            if(pos.is_array() && pos.size() >= 2){

              _htc_x = pos[0].get<double>();
              _htc_y = pos[1].get<double>();
            }

            _htc_angle = in["message"]["pose"]["attitude"][2].get<double>();
          }
        } catch(...){
        }
    }  
    
    // --- 3. IMU
    if (in["agent_id"].get<string>() == "imu_source") {
      //Variabili temporanee
      double gx_body = 0.0, gy_body = 0.0, gz_body = 0.0;
      double ax_body = 0.0, ay_body = 0.0, az_body = 0.0;
      
      //Gyro
        auto& gyro = in["message"]["gyro"];
          double raw_gx = gyro[0].get<double>();
          double raw_gy = gyro[1].get<double>();
          double raw_gz = gyro[2].get<double>();
          
          // Applicazione matrice di rotazione
          gx_body = raw_gy;
          gy_body = raw_gx;
          gz_body = -raw_gz;

      // Accel
        auto& accel = in["message"]["accel"];
          double raw_ay = accel[1].get<double>() * 9.80665;

          // Applicazione matrice di rotazione
          ax_body = raw_ay;
      
      // Process IMU Data if both gyro and accel are ready

        double dt_imu = _last_timecode - _prev_imu_timecode;
        if(dt_imu <= 0.0) dt_imu = 1e-6; // Prevenzione divisione per zero

        if(!_first_imu_frame){
          // Calcolo Accelerazione Angolare (Alpha = dOmega/dt)
          double alpha_x = (gx_body - _prev_gyro_x) / dt_imu;
          double alpha_y = (gy_body - _prev_gyro_y) / dt_imu;

          // Vettore Offset (lever arm)
          double rx = _conf.imu_offset_x;
          double ry = _conf.imu_offset_y;
          double rz = _conf.imu_offset_z;

          // Termine tangenziale (Alpha x R)
          double tan_x = alpha_y * rz - gz_body * ry;

          // Termine centripeto (Omega x (Omega x R))
          // Omega x R
          double oxr_y = gz_body * rx - gx_body * rz;
          double oxr_z = gx_body * ry - gy_body * rx;
          // Omega x (Omega x R)
          double cent_x = gy_body * oxr_z - gz_body * oxr_y;
        
          // Correzione finale
          double ax_corrected = ax_body - tan_x - cent_x;
          

          // Accelerometro X
          if(!_bias_computed){
            if(_calibration_samples < CALIBRATION_LIMIT){
              _bias_accel_x += ax_corrected;
              _bias_gyro_z += gz_body;
              _calibration_samples++;
              _current_accel_x = 0.0;
            } else {
              _bias_accel_x /= (double)CALIBRATION_LIMIT;
              _bias_gyro_z /= (double)CALIBRATION_LIMIT;
              _bias_computed = true;
              std::cout << "IMU Calibrated with lever arm. Bias acc_X: " << _bias_accel_x << " Bias gyro_Z: " << _bias_gyro_z << std::endl;
            }
          } else {
            _current_accel_x = ax_corrected - _bias_accel_x;
            //_current_gyro_z = _filter_gyro.update(gz_body * gyro_scaling - _bias_gyro_z); 
            _current_gyro_z = (gz_body - _bias_gyro_z)* _conf.gyro_scaling;

            
        }


      }
      // aggiorna storico per la derivata
        _prev_gyro_x = gx_body;
        _prev_gyro_y = gy_body;
        _prev_gyro_z = gz_body;
        _prev_imu_timecode = _last_timecode;
        _first_imu_frame = false;
      }   
    

    // RealSense
    if (in["agent_id"].get<string>() == "pose_rs_source") {
      
      auto& p = in["message"]["pose"];
        // Position
        if (p["position"][0].is_array()) {
          raw_rs_x = p["position"][0][0].get<double>();
          raw_rs_y = p["position"][0][1].get<double>();
        } else { // Capisci quale usi. AGGIORNAMENTO: CI SONO DUE FORMATI PERCHÈ I DATI NUOVI LI HANNO REGISTRATI IN UN SETUP LEGGERMENTE DIVERSO
          raw_rs_x = p["position"][0].get<double>();
          raw_rs_y = p["position"][1].get<double>();
        }

        // Angle (Handle nested arrays)
      if(p["attitude"][0].is_array()){
        raw_rs_theta = p["attitude"][0][2].get<double>();
      } else { // Capisci quale usi
        raw_rs_theta = p["attitude"][2].get<double>();
      }
 

      double delta_input = raw_rs_theta - _last_input_rs_theta;

      _last_input_rs_theta = raw_rs_theta;

      if(abs(delta_input) < 1e-6){ // semplicemente salta il dato se uguale al precedente o salta
        _filter_rs_x.clear(); //Non uso
        _filter_rs_y.clear();//Non uso
        _filter_rs_theta.clear();//Non uso
        //_first_rs_frame = true;
      } else {

      
      double total_angle = _conf.rs_global_rotation;
      double cos_rs = cos(total_angle);
      double sin_rs = sin(total_angle);

      _rs_x = (raw_rs_x * cos_rs - raw_rs_y * sin_rs);
      _rs_y = (raw_rs_x * sin_rs + raw_rs_y * cos_rs);

      double theta_new = raw_rs_theta + total_angle;

      while(theta_new > M_PI) theta_new -= 2.0 * M_PI;
      while(theta_new < -M_PI) theta_new += 2.0 * M_PI;
   
     

      _ekf_theta_rs = theta_new;
    
     // _rs_x = _filter_rs_x.update(_rs_x);
      //_rs_y = _filter_rs_y.update(_rs_y);
      //_rs_theta = _filter_rs_theta.update(theta_new);
      _rs_theta = theta_new;
      
      _has_rs_update = true;
      }
    }

    if(_conf.calibration_active == true){

      
        // Accumulate IMU data for calibration
        if(in["agent_id"].get<string>() == "imu_source") {
        _calib_acc_x.push_back(in["message"]["accel"][1].get<double>() * 9.80665);
        _calib_acc_y.push_back(in["message"]["accel"][0].get<double>() * 9.80665);
        _calib_gyro_z.push_back(in["message"]["gyro"][2].get<double>());
        }

        if(in["agent_id"].get<string>() == "pose_rs_source") {
          _calib_rs_x.push_back(in["message"]["pose"]["position"][0].get<double>());
          _calib_rs_y.push_back(in["message"]["pose"]["position"][1].get<double>());
          _calib_rs_theta.push_back(in["message"]["pose"]["attitude"][2].get<double>());
        }

        if(_calib_acc_x.size() > 0 && _calib_acc_x.size() % 500 == 0){
          double sig_ax = std_dev(_calib_acc_x);
          double sig_ay = std_dev(_calib_acc_y);
          double sig_gz = std_dev(_calib_gyro_z);
          double sig_rsx = std_dev(_calib_rs_x);
          double sig_rsy = std_dev(_calib_rs_y);
          double sig_rstheta = std_dev(_calib_rs_theta);

          std::cout << "---- Calibration Status ----" << std::endl;
          std::cout << "sigma_acc (Media X/Y) " << (sig_ax + sig_ay) / 2.0 << "(consigliato dinamico * 3)" << std::endl;
          std::cout << "Sigma gyro: " << sig_gz << "(Consigliato dinamico * 2)" << std::endl;
          std::cout << "sigma_rsx (Pos): " << sig_rsx << " m" << std::endl;
          std::cout << "sigma_rsy (Pos): " << sig_rsy << " m" << std::endl;
          std::cout << "sigma_rstheta (Pos): " << sig_rstheta << " rad" << std::endl;
          std::cout << "--------------------------------------" << std::endl;

          //_calib_acc_x.clear();
          //_calib_acc_y.clear();
          //_calib_gyro_z.clear();
          //_calib_rs_x.clear();
          //_calib_rs_y.clear();
          //_calib_rs_theta.clear();
        }

    }
  

    if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

  } catch (...){ return return_type::error; }
    return return_type::success;
  }
    


  // EKF Process
    return_type process(json &out) override {
        out.clear();

        // if no new data, skip
        if (!_has_new_encoder_data) { //this all gets updated ONLY if we have new encoder data
            return return_type::success; // O warning,
        }

        double current_dt = _last_timecode_enc - _prev_time;
        if(current_dt <= 0.01) return return_type::success; // Evita calcoli inutili

        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_encoder_data = false;

        double dt = current_dt;
        if (dt <= 1e-6) dt = 1e-6; // Prevenzione divisione per zero
        _prev_time = _last_timecode_enc;

        // --- PREDICTION ---
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;
        double ds = (d_right + d_left) / 2.0;
        double ds_only_enc = ds;

        // calcolo velocità e accelerazione encoder
        double v_enc_raw = ds / dt;
        _v_enc_smooth = (_conf.alpha_v * v_enc_raw) + ((1.0 - _conf.alpha_v) * _v_enc_smooth); // Low pass filter exponential

        double a_enc_raw = (_v_enc_smooth - _prev_v_enc) / dt;     
        _a_enc_smooth = (_conf.alpha_a * a_enc_raw) + ((1.0 - _conf.alpha_a) * _a_enc_smooth); // Low pass filter exponential

        double a_enc_sma = _filter_enc_a.update(_a_enc_smooth); // Moving average filter
        _prev_v_enc = _v_enc_smooth;

        // manipolazione valori imu per inserire ritardo artificiale simile a encoder
        _imu_accel_smooth_ema1 = (_conf.alpha_v * _current_accel_x) + ((1.0 - _conf.alpha_v) * _imu_accel_smooth_ema1);
        _imu_accel_smooth_ema2 = (_conf.alpha_a * _imu_accel_smooth_ema1) + ((1.0 - _conf.alpha_a) * _imu_accel_smooth_ema2);
        double a_imu_final = _filter_accel.update(_imu_accel_smooth_ema2);

        bool is_slipping = false;
        //double v_imu_pred = fused_velocity + (a_imu_final * dt); non usato nei filtri, inutile
        double accel_diff = abs(a_enc_sma - a_imu_final);
        //double v_diff = abs(v_imu_pred - _v_enc_smooth);

        //double var_enc_lin = pow(_conf.sigma_enc_lin, 2); inutilizzato
        //double var_acc_integrated = pow(_conf.sigma_acc * dt, 2); inutilizzato
        //double K_vel = var_acc_integrated / (var_acc_integrated + var_enc_lin); // guadagno di fusione velocità (quanto mi fido dell'encoder rispetto a IMU)

        if(_conf.enable_slip_check && _bias_computed){
            // 2. Acceleration Mismatch (Burnout Check)
            // Se gli encoder dicono "Partenza a razzo" (alta accel)
            // Ma l'IMU dice "Movimento blando"
          

          if (accel_diff > 0.5){
            is_slipping = true; // Rilevato slip
            if(abs(a_imu_final) < _conf.min_imu_accel_for_correction){
              ds = _prev_ds; //I should leave it as is?
            } else{
            //fused_velocity = v_imu_pred; // Aggiorna velocità fusa basata su IMU
            double ratio = abs(a_enc_sma) / abs(a_imu_final);

            if(ratio > 10) ratio = 10.0; // Limite massimo
            if(ratio < 0.1) ratio = 0.1; // Limite minimo
            //SE ACCELERAZIONE ~0 DS = PREV_DS

            ds = ds / ratio;
            }
          _prev_ds = ds;
          } else {
            // Nessun slip, usa velocità encoder
           // fused_velocity = _v_enc_smooth;
          }

            //ds = v_imu_pred * dt; // Usa velocità IMU predetta
            //fused_velocity = v_imu_pred; // Aggiorna velocità fusa basata su IMU
        } //else{

          // Fusione velocità ricalcolando i pesi in base alle varianze
          //double w_enc = var_acc_integrated / (var_acc_integrated + var_enc_lin);
          //double w_tot = (1.0/var_enc_lin) + (1.0/var_acc_integrated);
          //double k_enc = (1.0/var_enc_lin) / w_tot;
          //double k_imu = (1.0/var_acc_integrated) / w_tot;

          //fused_velocity = (k_enc * _v_enc_smooth) + (k_imu * v_imu_pred); // Nessun slip, usa velocità encoder
          //fused_velocity = ds/dt;
        //}
          
        /*
        if(abs(a_imu_final) < _conf.min_imu_accel_for_correction){
              //ds = _prev_ds; I should leave it as is?
            } else{
            double ratio = abs(a_enc_sma) / abs(a_imu_final);

            if(ratio > 10) ratio = 10.0; // Limite massimo
            //SE ACCELERAZIONE ~0 DS = PREV_DS

            ds = _conf.slip_ratio * ds / ratio;
            }
          _prev_ds = ds;
          }
          
        }
*/
        _debug_slip.enc_accel = a_enc_sma;
        _debug_slip.imu_accel = a_imu_final;
        _debug_slip.is_slipping = is_slipping;

        // _debug_slip.enc_vel = _v_enc_smooth;
        //_debug_slip.imu_vel = v_imu_pred;

        
        // rotation encoder
        double d_theta_enc = (d_right - d_left) / _conf.baseline;
        _debug_angle.angle_enc += d_theta_enc;

        while(_debug_angle.angle_enc > M_PI) _debug_angle.angle_enc -= 2.0 * M_PI;
        while(_debug_angle.angle_enc < -M_PI) _debug_angle.angle_enc += 2.0 * M_PI;

        // Rotation gyro
        //double d_theta_gyro = 0.0;
        double d_theta_gyro = _current_gyro_z * dt;
        _debug_angle.angle_imu += d_theta_gyro;
        while(_debug_angle.angle_imu > M_PI) _debug_angle.angle_imu -= 2.0 * M_PI;
        while(_debug_angle.angle_imu < -M_PI) _debug_angle.angle_imu += 2.0 * M_PI;
  

        //_debug_angle.avg_imu_enc = (_debug_angle.angle_imu + _debug_angle.angle_enc) / 2.0;


        //Fusione IMU/ENC
        double var_enc = _conf.sigma_enc_rot * _conf.sigma_enc_rot;
        double var_gyro = _conf.sigma_gyro * _conf.sigma_gyro;
        
        double weight_gyro = var_enc / (var_enc + var_gyro);
        double weight_enc = var_gyro / (var_enc + var_gyro);
        
        double d_theta_fused = (d_theta_gyro * weight_gyro) + (d_theta_enc * weight_enc);
        //double d_theta_fused = (d_theta_gyro);

        // Calcolo varianze per update PXX
        //incertezza lineare
        double motion_error_lin = is_slipping ? 0.5 : _conf.sigma_v; // Aumenta incertezza se slittamento
        double sigma_ds = (motion_error_lin * abs(ds)) + (0.01*dt); // % del movimento + drift temporale

        // incertezza angolare
        //double combined_sigma = sqrt(pow(_conf.sigma_gyro * weight_gyro, 2) + pow(_conf.sigma_enc_rot * weight_enc, 2));
        double motion_error_ang = _conf.sigma_w;
        double sigma_dtheta = (motion_error_ang * abs(d_theta_fused)) + (0.01*dt); // come caso lineare
        // viene aggiunto (0.01*dt) per evitare varianza nulla in caso di movimento zero. In questo modo aggiorniamo la matrice P aumentando l'incertezza nel tempo, rivelando eventuali errori di deriva.

        ekf_predict(_state, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        ekf_predict(_state_partial, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        
        //Update Stati
        
        // Raw encoder only state - ODOMETRIA PURA
        double avg_theta_enc = _state_enc_only.theta + d_theta_enc / 2.0;
        _state_enc_only.x += ds_only_enc * cos(avg_theta_enc);
        _state_enc_only.y += ds_only_enc * sin(avg_theta_enc);
        _state_enc_only.theta = normalize_angle(_state_enc_only.theta + d_theta_enc);

        
        // Correction
        if(_has_rs_update){

          // Dataset logic
          if(_conf.aruco_is_walker_center){
            est_rs_x = _rs_x;
            est_rs_y = _rs_y;
          }else{
          
          est_rs_x = _rs_x + (cos(_rs_theta) * _conf.cam_offset_x - sin(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_x;
          est_rs_y = _rs_y + (sin(_rs_theta) * _conf.cam_offset_x + cos(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_y;
          }
          
          Vector3d Z;
          Z << est_rs_x, est_rs_y, _ekf_theta_rs;

          Matrix3d R = Matrix3d::Zero();
          R(0, 0) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(1, 1) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(2, 2) = _conf.sigma_rs_ang * _conf.sigma_rs_ang;

          ekf_update(_state, Z, R);

          _has_rs_update = false;
        }

        // OUTPUT
        
        // Odometry
        out["debug"]["raw_encoder_only"] = std::vector<double>{_state_enc_only.x, _state_enc_only.y, 0.0};

        // Partial EKF (odom + imu)
        out["debug"]["partial_ekf"] = std::vector<double>{_state_partial.x(0), _state_partial.x(1), 0.0};

        // Full EKF
        out["pose"]["position"] = std::vector<double>{_state.x(0), _state.x(1), 0.0};
        out["pose"]["orientation"] = _state.x(2);

        // Slip debug
        out["debug"]["accel_enc"] = _debug_slip.enc_accel;
        out["debug"]["accel_imu"] = _debug_slip.imu_accel;
        out["debug"]["is_slipping"] = _debug_slip.is_slipping ? 1.0 : 0.0;
        //out["debug"]["vel_imu"] = _debug_slip.imu_vel;
        //out["debug"]["vel_enc"] = _debug_slip.enc_vel;
       // out["debug"]["fused_velocity"] = fused_velocity;

        // Angles debug
        out["debug"]["angles"]["theta_enc"] = _debug_angle.angle_enc;
        out["debug"]["angles"]["theta_imu"] = _debug_angle.angle_imu;
        //out["debug"]["angles"]["theta_fused_imu_enc"] = _debug_angle.avg_imu_enc;
        //out["debug"]["angles"]["rs_raw"] = raw_rs_theta; not going to be used anymore
        out["debug"]["angles"]["theta_rs"] = _rs_theta;
        out["debug"]["angles"]["fused_full"] = _state.x(2);
        out["debug"]["angles"]["fused_partial"] = _state_partial.x(2);
        //out["debug"]["angles"]["enc_only"] = _state_enc_only.theta;
        //out["debug"]["angles"]["ekf_rs"] = _ekf_theta_rs;

        //double theta_rs = _rs_theta_unwrapped;
        out["debug"]["rs_center"] = std::vector<double>{est_rs_x, est_rs_y, 0.0};

        //htc position
        out["debug"]["htc_position"] = std::vector<double>{_htc_x, _htc_y, 0.0};
        out["debug"]["angles"]["htc_angle"] = _htc_angle;
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timecode;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];


    if(p.contains("sigma_v")) _conf.sigma_v = p["sigma_v"];
    if(p.contains("sigma_w")) _conf.sigma_w = p["sigma_w"];
    if(p.contains("sigma_acc")) _conf.sigma_acc = p["sigma_acc"];
    if(p.contains("sigma_enc_lin")) _conf.sigma_enc_lin = p["sigma_enc_lin"];
    if(p.contains("sigma_enc_rot")) _conf.sigma_enc_rot = p["sigma_enc_rot"];
    if(p.contains("sigma_gyro")) _conf.sigma_gyro = p["sigma_gyro"];
    if(p.contains("sigma_rs_pos")) _conf.sigma_rs_pos = p["sigma_rs_pos"];
    if(p.contains("sigma_rs_ang")) _conf.sigma_rs_ang = p["sigma_rs_ang"];
    
    if(p.contains("alpha_a")) _conf.alpha_a = p["alpha_a"];
    if(p.contains("alpha_v")) _conf.alpha_v = p["alpha_v"];
    if(p.contains("slip_ratio")) _conf.slip_ratio = p["slip_ratio"];
 
    

    if( p.contains("cam_offset_x")) _conf.cam_offset_x = p["cam_offset_x"];
    if( p.contains("cam_offset_y")) _conf.cam_offset_y = p["cam_offset_y"];

    if( p.contains("rs_global_rotation")) _conf.rs_global_rotation = p["rs_global_rotation"];

    if( p.contains("filter_window_imu")) _conf.filter_window_imu = p["filter_window_imu"];
    if( p.contains("filter_window_enc")) _conf.filter_window_enc = p["filter_window_enc"];
    if(p.contains("filter_window_rs")) _conf.filter_window_rs = p["filter_window_rs"];
    //if( p.contains("invert_gyro")) _conf.invert_gyro = p["invert_gyro"];

    //if (p.contains("slip_accel_thresh")) _conf.slip_accel_thresh = p["slip_accel_thresh"];
    if (p.contains("min_imu_accel_for_correction")) _conf.min_imu_accel_for_correction = p["min_imu_accel_for_correction"];
    if (p.contains("enable_slip_check")) _conf.enable_slip_check = p["enable_slip_check"];
    if(p.contains("slip_accel_ratio")) _conf.slip_accel_ratio = p["slip_accel_ratio"];

    if(p.contains("aruco_is_walker_center")) _conf.aruco_is_walker_center = p["aruco_is_walker_center"];

    if(p.contains("calibration_active")) _conf.calibration_active = p["calibration_active"];
    if(p.contains("gyro_scaling")) _conf.gyro_scaling = p["gyro_scaling"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    
    _state.x = Vector3d::Zero();
    _state.P = Matrix3d::Identity() * 0.01; // Pic

    _state_partial.x = Vector3d::Zero();
    _state_partial.P = Matrix3d::Identity() * 0.01; //
    
    _state_enc_only = {0,0,0}; // Reset stato raw
    _debug = {0,0};
    _initialized = false;
    _prev_raw_rs_x = -9999.0;
    _prev_raw_rs_y = -9999.0;
    //_first_rs_frame = true;
    _rs_theta_unwrapped = 0.0;
    //_prev_rs_theta_raw = 0.0;
    //fused_velocity = 0.0;
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  //double _prev_rs_theta_raw = 0.0;
  double _rs_theta_unwrapped = 0.0;
  //bool _first_rs_frame = true;

  double _last_input_rs_theta = 0.0;
  //bool _aruco_valid_for_vis = false;

  double est_rs_x = 0.0;
  double est_rs_y = 0.0;

  //double fused_velocity = 0.0;
  double v_enc = 0.0;
  double v_imu = 0.0;
  double prev_imu_vel = 0.0;
 
  

 //double raw_rs_theta = 0.0;


  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    //in["encoders"]["left"] = 100;
    //in["encoders"]["right"] = 100;
    
    //f.load_data(in);
    //f.process(out);

   // std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}



