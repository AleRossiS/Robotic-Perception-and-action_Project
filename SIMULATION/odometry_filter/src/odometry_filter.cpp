/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
/*
# FINAL EKF: WEIGHTED SENSOR FUSION
# Approach:
# 1. Calculate Rotation from Encoders (High drift on turns)
# 2. Calculate Rotation from Gyro (Drift over time, precise on turns)
# 3. Fuse them based on Variance (Confidence)
# 4. Use RealSense for absolute Position Correction
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
#include <deque>
#include <numeric>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class MovingAverage {
    std::deque<double> _window;
    size_t _size;
    double _sum = 0.0;
public:
    MovingAverage(size_t size = 10) : _size(size), _sum(0.0) {}
    
    void resize(size_t new_size) { _size = new_size; _window.clear(); _sum = 0.0; }

    double update(double val) {
        _window.push_back(val);
        _sum += val;
        if (_window.size() > _size){
          double removed = _window.front();
          _sum -= removed;
          _window.pop_front();
        } 

        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }
};

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato interno del Robot (Pose)
    struct State {
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0; // Radianti

        double Pxx = 0.01;  // Cov X
        double Pyy = 0.01;  // Cov Y
        double Ptt = 0.01; // Cov Theta
    } _state;

    struct StateRaw{
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0;
    } _state_enc_only;

    struct DebugState {
        double theta_enc_only = 0.0;
        double theta_imu_only = 0.0;
    } _debug;

    struct DebugSlip {
        double enc_accel = 0.0;
        double imu_accel = 0.0;
        bool is_slipping = false; 
    } _debug_slip;


    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] (Esempio, da calibrare)
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;            // B [m] No baseline needed with gyro
        double ticks_per_rev = 4096.0;     // Risoluzione Encoder

        // kalman tuning
        double sigma_v = 0.005;  // vel uncertainty encoder
        double sigma_w = 0.002; // gyro uncertainty
        double sigma_rs_pos = 0.8;  // RealSense uncertainty
        double sigma_rs_ang = 0.5;  // RealSense angle uncertainty

        double sigma_enc_lin = 0.005; // Errore encoder lineare (m/s)
        double sigma_enc_rot = 0.05;  // Errore encoder rotazionale (rad/s)
        double sigma_gyro    = 0.002; // Errore giroscopio (rad/s)

        double slip_accel_thresh = 0.5; // Soglia accelerazione per slip
        double static_thresh = 0.05;    // Soglia per considerare ferm
        bool enable_slip_check = true;

        int filter_window_rs = 10;
        int filter_window_imu = 5;  
        int filter_window_acc = 10; // Finestra per accelerometro    

        double rs_global_rotation = 0.0;
        double cam_offset_x = 0.0;
        double cam_offset_y = 0.0;
        bool invert_gyro = true;
    } _conf;

    // BUffer data:
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;

    // Encoder memory
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;
    bool _has_new_encoder_data = false;

    // Moving Average Filters
    MovingAverage _filter_rs_x;
    MovingAverage _filter_rs_y;
    MovingAverage _filter_rs_theta;

    string _last_agent_id = "";
    double _last_timestamp = 0.0;
    double _prev_time = 0.0;

    // IMU Data
    MovingAverage _filter_gyro;
    MovingAverage _filter_accel; // Filtro per Accel X
    double _current_gyro_z = 0.0;
    double _current_accel_x = 0.0;
    bool _has_gyro = false;
    bool _has_imu = false;

    double _prev_v_enc = 0.0; // Velocità precedente (per calcolo accel)

    // Memory for anti-freeze check
    double _prev_raw_rs_x = -9999.0;
    double _prev_raw_rs_y = -9999.0;

    // Correction data RealSense
    double _rs_x = 0.0;
    double _rs_y = 0.0;
    double _rs_theta = 0.0;
    bool _has_rs_update = false;

   

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "EKF + Raw Encoder + anti-slip logic"},
        };
  }

  Odometry_filterPlugin() : _filter_rs_x(10), _filter_rs_y(10), _filter_rs_theta(10), _filter_gyro(5), _filter_accel(10) {}
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {

    // Timestamp
    double now = 0.0;
    if(in.contains("message") && in["message"].contains("timecode")){
        now = in["message"]["timecode"].get<double>();
    } else if (in.contains("/message/timecode")) {
        now = in["/message/timecode"].get<double>();
    }
    if(now > 0) _last_timestamp = now;

    // Encoders
    if (in.contains("/message/encoders/left") || (in.contains("message") && in["message"].contains("encoders"))) {
        if (in.contains("/message/encoders/left")) {
            _incoming_ticks_l = (long)in["/message/encoders/left"].get<double>();
            _incoming_ticks_r = (long)in["/message/encoders/right"].get<double>();
        } else {
            _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
            _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
        }

        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _prev_time = _last_timestamp;
            _initialized = true;
        } else {
            _has_new_encoder_data = true;
        }
    }
    
    // --- 3. IMU (NUOVO FORMATO: Array Piatto) ---
    if (in.contains("message")){
      //Gyro
      if (in["message"].contains("gyro")) {
        auto& gyro = in["message"]["gyro"];
        if (gyro.is_array() && gyro.size() >= 3) {
          double raw_gyro = gyro[2].get<double>();
          if (_conf.invert_gyro) raw_gyro = -raw_gyro;
          _current_gyro_z = _filter_gyro.update(raw_gyro);
          _has_gyro = true; 
        }
      }
      // Accel
      if (in["message"].contains("accel")) {
        auto& accel = in["message"]["accel"];
        if (accel.is_array() && accel.size() >= 1) {
          double raw_accel = accel[0].get<double>();
          _current_accel_x = _filter_accel.update(raw_accel);
        }
      }   
    }

    // RealSense
    double raw_rs_x = 0.0, raw_rs_y = 0.0, raw_rs_theta = 0.0;
    bool rs_found = false;

    if (in.contains("message") && in["message"].contains("pose")) {
      auto& p = in["message"]["pose"];
        // Position
      if (p.contains("position") && p["position"].is_array() && p["position"].size() > 0) {
        // Check if it's [[x,y,z]] or [x,y,z]
        if (p["position"][0].is_array()) {
          raw_rs_x = p["position"][0][0].get<double>();
          raw_rs_y = p["position"][0][1].get<double>();
        } else {
          raw_rs_x = p["position"][0].get<double>();
          raw_rs_y = p["position"][1].get<double>();
        }
        rs_found = true;
      }
      
      
      // Angle (Handle nested arrays)
      if (p.contains("attitude_along_z")) {
        auto& att = p["attitude_along_z"];
        if (att.is_array()) raw_rs_theta = att[0].get<double>(); // If array
        else raw_rs_theta = att.get<double>(); // If scalar
      }
    }

    // Anti-freeze check & filtering
    if (rs_found && (abs(raw_rs_x) > 0.001 || abs(raw_rs_y) > 0.001)) {

      //Specchio
        double rot = _conf.rs_global_rotation;
        double x_new = -(raw_rs_x * cos(rot) - raw_rs_y * sin(rot));
        double y_new = (raw_rs_x * sin(rot) + raw_rs_y * cos(rot));
        raw_rs_x = x_new;
        raw_rs_y = y_new;
        raw_rs_theta += rot;
      

      double dist = sqrt(pow(raw_rs_x - _prev_raw_rs_x, 2) + pow(raw_rs_y - _prev_raw_rs_y, 2));
      if (dist > 0.0001) { // Not stuck
                _rs_x = _filter_rs_x.update(raw_rs_x);
                _rs_y = _filter_rs_y.update(raw_rs_y);
                _rs_theta = _filter_rs_theta.update(raw_rs_theta);
                
                _has_rs_update = true;

                _prev_raw_rs_x = raw_rs_x;
                _prev_raw_rs_y = raw_rs_y;
            }
          }

    if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

  } catch (...){ return return_type::error; }
    return return_type::success;
  }
    


  // EKF Process
    return_type process(json &out) override {
        out.clear();

        // if no new data, skip
        if (!_has_new_encoder_data) {
            return return_type::success; // O warning,
        }

        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_encoder_data = false;

        double dt = _last_timestamp - _prev_time;
        if (dt <= 0) dt = 1e-6;
        _prev_time = _last_timestamp;

        // --- PREDICTION (Usa Gyroscope!) ---
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;
        double ds = (d_right + d_left) / 2.0;

        
        // calcolo velocità e accelerazione encoder
        double v_enc = ds / dt;
        double a_enc = (v_enc - _prev_v_enc) / dt;
        _prev_v_enc = v_enc;

        bool is_slipping = false;

        if(_conf.enable_slip_check){
            // 1. ZUPT (Zero Velocity Update)
            // Se l'IMU dice che l'accelerazione è NULLA e il Gyro è fermo...
            // ...ma gli encoder segnano movimento -> Slittamento da fermo!
            if (abs(_current_accel_x) < _conf.static_thresh && abs(_current_gyro_z) < 0.01) {
              if(abs(v_enc) > 0.001){
                is_slipping = true;
                ds = 0.0; // FORZA FERMO
            } 
          }
            // 2. Acceleration Mismatch (Burnout Check)
            // Se gli encoder dicono "Partenza a razzo" (alta accel)
            // Ma l'IMU dice "Movimento blando"
            else if (abs(a_enc) > 0.5 && abs(_current_accel_x) < _conf.slip_accel_thresh) {
                    is_slipping = true; // Rilevato slip
                    ds *= 0.1;
                }
          
        }

        _debug_slip.enc_accel = a_enc;
        _debug_slip.imu_accel = _current_accel_x;
        _debug_slip.is_slipping = is_slipping;

        
        // rotation encoder
        double d_theta_enc = (d_right - d_left) / _conf.baseline;
        // Rotation gyro
        double d_theta_gyro = 0.0;
        if(_has_gyro){
            d_theta_gyro = _current_gyro_z * dt;
        }

        // Update raw encoder only state
        double avg_theta_enc = _state_enc_only.theta + d_theta_enc / 2.0;
        _state_enc_only.x += ds * cos(avg_theta_enc);
        _state_enc_only.y += ds * sin(avg_theta_enc);
        _state_enc_only.theta += d_theta_enc;


        double var_enc = _conf.sigma_enc_rot * _conf.sigma_enc_rot;
        double var_gyro = _conf.sigma_gyro * _conf.sigma_gyro;

        double weight_gyro = 0.0;
        double weight_enc = 1.0;
        if(_has_gyro){
            weight_gyro = var_enc / (var_enc + var_gyro);
            weight_enc = var_gyro / (var_enc + var_gyro);
        }

        double d_theta_fused = (d_theta_gyro * weight_gyro) + (d_theta_enc * weight_enc);

        double avg_theta = _state.theta + d_theta_fused / 2.0;
        

        // Update state
        _state.x += ds * cos(avg_theta);
        _state.y += ds * sin(avg_theta);
        _state.theta += d_theta_fused;

        // Normalization Theta
        while (_state.theta > M_PI) _state.theta -= 2.0 * M_PI;
        while (_state.theta < -M_PI) _state.theta += 2.0 * M_PI;
        
        _state.Pxx += _conf.sigma_enc_lin * abs(ds);
        _state.Pyy += _conf.sigma_enc_lin * abs(ds);

        double combined_sigma = sqrt(pow(_conf.sigma_gyro * weight_gyro, 2) + pow(_conf.sigma_enc_rot * weight_enc, 2));
        _state.Ptt += combined_sigma * abs(d_theta_fused);

        double sigma_curr = is_slipping ? 1.0 : _conf.sigma_v; // Aumenta incertezza se slittamento
        _state.Pxx += sigma_curr * abs(ds);
        _state.Pyy += sigma_curr * abs(ds);
        _state.Ptt += _conf.sigma_w * abs(d_theta_fused);

        // Correction
        if(_has_rs_update){

          double est_sensor_x = _state.x + cos(_state.theta) * _conf.cam_offset_x - sin(_state.theta) * _conf.cam_offset_y;
          double est_sensor_y = _state.y + sin(_state.theta) * _conf.cam_offset_x + cos(_state.theta) * _conf.cam_offset_y;
          // --- CORRECTION ---
          double innov_x = _rs_x - est_sensor_x;
          double innov_y = _rs_y - est_sensor_y;
            
          // Position correction
          double K_x = _state.Pxx / (_state.Pxx + _conf.sigma_rs_pos);
          double K_y = _state.Pyy / (_state.Pyy + _conf.sigma_rs_pos);

          _state.x += K_x * innov_x;
          _state.y += K_y * innov_y;

          _state.Pxx *= (1.0 - K_x);
          _state.Pyy *= (1.0 - K_y);

          // Angle correction
          double y_theta = _rs_theta - _state.theta;
          while (y_theta > M_PI) y_theta -= 2.0 * M_PI;
          while (y_theta < -M_PI) y_theta += 2.0 * M_PI;

          double K_t = _state.Ptt / (_state.Ptt + _conf.sigma_rs_ang);

          _state.theta += K_t * y_theta;
          _state.Ptt *= (1.0 - K_t);

          _has_rs_update = false;
        }

        _debug.theta_enc_only = d_theta_enc;
        _debug.theta_imu_only = d_theta_gyro;

        // OUTPUT
        out["pose"]["position"]["x"] = _state.x;
        out["pose"]["position"]["y"] = _state.y;
        out["pose"]["position"]["z"] = 0.0;
        out["pose"]["orientation"]["yaw"] = _state.theta;

        std::vector<double> pos_vec = {_state.x, _state.y, 0.0};
        out["pose_vector"] = pos_vec;

        out["debug"]["raw_encoder_only"] = std::vector<double>{_state_enc_only.x, _state_enc_only.y, 0.0};

        out["debug"]["theta_enc"] = _debug.theta_enc_only;
        out["debug"]["theta_imu"] = _debug.theta_imu_only;
        //out["debug"]["theta_fused"] = _state.theta;

        out["debug"]["accel_enc"] = _debug_slip.enc_accel;
        out["debug"]["accel_imu"] = _debug_slip.imu_accel;
        out["debug"]["is_slipping"] = _debug_slip.is_slipping ? 1.0 : 0.0;
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timestamp;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];

    if(p.contains("sigma_enc_lin")) _conf.sigma_enc_lin = p["sigma_enc_lin"];
    if(p.contains("sigma_enc_rot")) _conf.sigma_enc_rot = p["sigma_enc_rot"];
    if(p.contains("sigma_gyro")) _conf.sigma_gyro = p["sigma_gyro"];
    if(p.contains("sigma_rs_pos")) _conf.sigma_rs_pos = p["sigma_rs_pos"];
    if(p.contains("sigma_rs_ang")) _conf.sigma_rs_ang = p["sigma_rs_ang"];

    if (p.contains("filter_window_rs")) {
            _conf.filter_window_rs = p["filter_window_rs"];
            _filter_rs_x.resize(_conf.filter_window_rs);
            _filter_rs_y.resize(_conf.filter_window_rs);
    }

    if (p.contains("filter_window_imu")) {
      _conf.filter_window_imu = p["filter_window_imu"];
      _filter_gyro.resize(_conf.filter_window_imu);
      _filter_accel.resize(_conf.filter_window_acc);
    }

    

    if( p.contains("cam_offset_x")) _conf.cam_offset_x = p["cam_offset_x"];
    if( p.contains("cam_offset_y")) _conf.cam_offset_y = p["cam_offset_y"];
    if( p.contains("rs_global_rotation")) _conf.rs_global_rotation = p["rs_global_rotation"];
    if( p.contains("invert_gyro")) _conf.invert_gyro = p["invert_gyro"];

    if (p.contains("slip_accel_thresh")) _conf.slip_accel_thresh = p["slip_accel_thresh"];
    if (p.contains("static_thresh")) _conf.static_thresh = p["static_thresh"];
    if (p.contains("enable_slip_check")) _conf.enable_slip_check = p["enable_slip_check"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    _state = {0, 0, 0, 0.01, 0.01, 0.01};
    _state_enc_only = {0,0,0}; // Reset stato raw
    _debug = {0,0};
    _initialized = false;
    _prev_raw_rs_x = -9999.0;
    _prev_raw_rs_y = -9999.0;
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    in["encoders"]["left"] = 100;
    in["encoders"]["right"] = 100;
    
    f.load_data(in);
    f.process(out);

    std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}