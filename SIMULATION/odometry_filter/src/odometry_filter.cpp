/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
/*
# FINAL EKF: WEIGHTED SENSOR FUSION
# Approach:
# 1. Calculate Rotation from Encoders (High drift on turns)
# 2. Calculate Rotation from Gyro (Drift over time, precise on turns)
# 3. Fuse them based on Variance (Confidence)
# 4. Use RealSense for absolute Position Correction
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
#include <deque>
#include <numeric>
#include <Eigen/Dense>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace Eigen;
using namespace std;
using json = nlohmann::json;

// Normalizzazione angoli
double normalize_angle(double angle) {
    while (angle > M_PI) angle -= 2.0 * M_PI;
    while (angle < -M_PI) angle += 2.0 * M_PI;
    return angle;
}

//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif


class MovingAverage {
    std::deque<double> _window;
    size_t _size;
    double _sum = 0.0;
public:
    MovingAverage(size_t size = 10) : _size(size), _sum(0.0) {}
    
    void resize(size_t new_size) { _size = new_size; _window.clear(); _sum = 0.0; }

    void clear() { _window.clear(); _sum = 0.0; }

    double update(double val) {
        _window.push_back(val);
        _sum += val;
        if (_window.size() > _size){
          double removed = _window.front();
          _sum -= removed;
          _window.pop_front();
        } 

        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }
};


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato con eigen
  struct State{
    Vector3d x; // Stato: [x, y, theta]
    Matrix3d P; // Covarianza 3x3 
  };

    State _state;
    State _state_partial; // EKF parziale (Solo encoder + RS)

    struct StateRaw{
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0;
    } _state_enc_only;

    struct DebugState {
        double theta_enc_only = 0.0;
        double theta_imu_only = 0.0;
    } _debug;

    struct DebugSlip {
        double enc_accel = 0.0;
        double imu_accel = 0.0;
        bool is_slipping = false; 
    } _debug_slip;


    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] (Esempio, da calibrare)
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;            // B [m] No baseline needed with gyro
        double ticks_per_rev = 4096.0;     // Risoluzione Encoder

        // kalman tuning
        double sigma_v = 0.005;  // vel uncertainty encoder
        double sigma_w = 0.002; // gyro uncertainty
        double sigma_rs_pos = 0.8;  // RealSense uncertainty
        double sigma_rs_ang = 0.5;  // RealSense angle uncertainty

        double sigma_enc_lin = 0.005; // Errore encoder lineare (m/s)
        double sigma_enc_rot = 0.05;  // Errore encoder rotazionale (rad/s)
        double sigma_gyro    = 0.002; // Errore giroscopio (rad/s)

        //double slip_accel_thresh = 0.5; // Soglia accelerazione per slip
        double min_imu_accel_for_correction = 0.05;    // Soglia per considerare ferm
        bool enable_slip_check = true;
        double slip_accel_ratio = 1.5;   // Rapporto accel a_enc / a_imu

        int filter_window_rs = 10;
        int filter_window_imu = 5;  
        int filter_window_enc = 10; // Finestra per accelerometro    

        double rs_global_rotation = 0.0;
        double cam_offset_x = 0.80;
        double cam_offset_y = 0.0;
        //bool invert_gyro = true;

        // Parametri Offset IMU (Lever Arm) nel frame del Robot
        double imu_offset_x = 0.70;
        double imu_offset_y = 0.20;
        double imu_offset_z = 0.00;
        
    } _conf;

    // BUffer data:
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;

    // Encoder memory
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;
    bool _has_new_encoder_data = false;
    double _prev_ds = 0.0;

    // Moving Average Filters
    MovingAverage _filter_rs_x; //Non uso
    MovingAverage _filter_rs_y; //Non uso
    MovingAverage _filter_rs_theta; //Non uso

    //MovingAverage _filter_enc_v; // Rimosso, uso filtro esponenziale inline
    MovingAverage _filter_enc_a; // filtro ibrido per accelerazione encoder

    string _last_agent_id = "";
    double _last_timecode = 0.0;
    double _prev_time = 0.0;

    // IMU Data
    MovingAverage _filter_gyro;
    MovingAverage _filter_accel; // Filtro per Accel X
    double _current_gyro_z = 0.0;
    double _current_accel_x = 0.0;
    bool _has_gyro = false;
    bool _has_imu = false;

    double _bias_accel_x = 0.0;
    int _calibration_samples = 0;
    bool _bias_computed = false;
    const int CALIBRATION_LIMIT = 400;
    
    double _imu_accel_smooth_ema1 = 0.0;
    double _imu_accel_smooth_ema2 = 0.0;

    // Mem per calcolare derivata angolare
    double _prev_gyro_x = 0.0;
    double _prev_gyro_y = 0.0;
    double _prev_gyro_z = 0.0;
    double _prev_imu_timecode = 0.0;
    bool _first_imu_frame = true;

    double _v_enc_smooth = 0.0;
    double _a_enc_smooth = 0.0;
    double _prev_v_enc = 0.0; 

    // Memory for anti-freeze check
    double _prev_raw_rs_x = -9999.0;
    double _prev_raw_rs_y = -9999.0;
    double _ekf_theta_rs = 0.0;

    // Correction data RealSense
    double _rs_x = 0.0;
    double _rs_y = 0.0;
    double _rs_theta = 0.0;
    bool _has_rs_update = false;

   

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "EKF + Raw Encoder + anti-slip logic + ARUCO"},
        };
  }

  Odometry_filterPlugin() : 
    _filter_rs_x(10), //Non uso
    _filter_rs_y(10), //Non uso
    _filter_rs_theta(10), //Non uso
    _filter_gyro(_conf.filter_window_imu), //Aumento?
    _filter_accel(_conf.filter_window_imu),//Aumento?
    //_filter_enc_v(10),
    _filter_enc_a(_conf.filter_window_enc)//Aumento?
    {}
  
  // -- Funzione di predizione EKF
void ekf_predict(State &s, double ds, double d_theta, double sigma_ds, double sigma_dth) {
  double theta = s.x(2);
  double cos_th = cos(theta + d_theta/2.0); // Half-angle approx per Runge-Kutta
  double sin_th = sin(theta + d_theta/2.0);

  // Predizione Stato
  s.x(0) += ds * cos_th;
  s.x(1) += ds * sin_th;
  s.x(2) += d_theta;
  s.x(2) = normalize_angle(s.x(2));

  // Jacobiano F (3x3)
  Matrix3d F = Matrix3d::Identity();
  F(0, 2) = -ds * sin_th;
  F(1, 2) =  ds * cos_th;
  
  // Matrice Rumore di Processo Q
  Matrix3d Q = Matrix3d::Zero();
  double var_ds = sigma_ds * sigma_ds;
  double var_dth = sigma_dth * sigma_dth;

  // Proiezione rumore
  Q(0, 0) = var_ds * cos_th * cos_th + 1e-9;
  Q(1, 1) = var_ds * sin_th * sin_th + 1e-9;
  Q(2, 2) = var_dth + 1e-9;

  // PREDIZIONE COVARIANZA: P = F * P * F^T + Q
  s.P = (F * s.P * F.transpose()) + Q;
}

// --- FUNZIONE DI CORREZIONE EKF (UPDATE) ---
void ekf_update(State &s, const Vector3d &z, const Matrix3d &R) {
  // Z = Misura [x, y, theta]
  // R Covarianza Misura

  Vector3d y = z - s.x; 

  y(2) = normalize_angle(y(2));

  Matrix3d H = Matrix3d::Identity();
  Matrix3d S = H * s.P * H.transpose() + R;
  Matrix3d K = s.P * H.transpose() * S.inverse();

  s.x = s.x + K * y;
  s.x(2) = normalize_angle(s.x(2));

  Matrix3d I = Matrix3d::Identity();
  s.P = (I - K * H) * s.P;
}
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {

    // Timecode
    if(in["message"].contains("timecode")){
        _last_timecode = in["message"]["timecode"].get<double>();
    } //else if (in.contains("/message/timecode")) { //controlla quale viene usato
        //now = in["/message/timecode"].get<double>();
    //}
    //if(now > 0) _last_timecode = now; //controlla aggiornamento timecode per encoder calcolo velocità e acc

    // Encoders
    if (in["message"].contains("encoders")) {
        //if (in.contains("/message/encoders/left")) {
        //    _incoming_ticks_l = (long)in["/message/encoders/left"].get<double>();
        //    _incoming_ticks_r = (long)in["/message/encoders/right"].get<double>();
        //} 
        //controlla quale viene usato
            _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
            _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
        

        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _prev_time = _last_timecode;
            _initialized = true;
        } else {
            _has_new_encoder_data = true;
        }
    }
    
    // --- 3. IMU (NUOVO FORMATO: Array Piatto) ---
    if (in["message"].contains("gyro") || in["message"].contains("accel")) {
      //Variabili temporanee
      double gx_body = 0.0, gy_body = 0.0, gz_body = 0.0;
      double ax_body = 0.0, ay_body = 0.0, az_body = 0.0;
      

      //Gyro
      //if (in["message"].contains("gyro")) {
        auto& gyro = in["message"]["gyro"];
        //if (gyro.is_array() && gyro.size() >= 3) {
          double raw_gx = gyro[0].get<double>();
          double raw_gy = gyro[1].get<double>();
          double raw_gz = gyro[2].get<double>();
          
          // Applicazione matrice di rotazione R = Rx(180) * Rz(-90)
          // X_new = y_old, Y_new = x_old, Z_new = -z_old
          gx_body = raw_gy;
          gy_body = raw_gx;
          gz_body = -raw_gz;


        //}
      //}

      // Accel
      //if (in["message"].contains("accel")) {
        auto& accel = in["message"]["accel"];
        //if (accel.is_array() && accel.size() >= 1) {
          double raw_ax = accel[0].get<double>() * 9.80665;
          double raw_ay = accel[1].get<double>() * 9.80665;
          double raw_az = accel[2].get<double>() * 9.80665;
          
          ax_body = raw_ay;
          ay_body = raw_ax;
          az_body = -raw_az;
        //}
      
      // Process IMU Data if both gyro and accel are ready

        double dt_imu = _last_timecode - _prev_imu_timecode;
        if(dt_imu <= 0.0) dt_imu = 1e-6; // Prevenzione divisione per zero

        if(!_first_imu_frame){
          // Calcolo Accelerazione Angolare (Alpha = dOmega/dt)
          double alpha_x = (gx_body - _prev_gyro_x) / dt_imu;
          double alpha_y = (gy_body - _prev_gyro_y) / dt_imu;
          //double alpha_z = (gz_body - _prev_gyro_z) / dt_imu; // Non uso

          // Vettore Offset (lever arm)
          double rx = _conf.imu_offset_x;
          double ry = _conf.imu_offset_y;
          double rz = _conf.imu_offset_z;

          // Termine tangenziale (Alpha x R)
          double tan_x = alpha_y * rz - gz_body * ry;
          //double tan_y = gz_body * rx - alpha_x * rz; // Non uso
          //double tan_z = alpha_x * ry - alpha_y * rx; // Non uso

          // Termine centripeto (Omega x (Omega x R))
          // Omega x R
          //double oxr_x = gy_body * rz - gz_body * ry; // Non uso
          double oxr_y = gz_body * rx - gx_body * rz;
          double oxr_z = gx_body * ry - gy_body * rx;
          // Omega x (Omega x R)
          double cent_x = gy_body * oxr_z - gz_body * oxr_y;
          //double cent_y = gz_body * oxr_x - gx_body * oxr_z; // Non uso
          //double cent_z = gx_body * oxr_y - gy_body * oxr_x; // Non uso
          
          // Correzione finale
          // a_body = a_measured - a_tangential - a_centripetal
          double ax_corrected = ax_body - tan_x - cent_x;

          // Aggiorna filtro
          //double val_gyro_z = _conf.invert_gyro ? -gz_body : gz_body;
          _current_gyro_z = _filter_gyro.update(gz_body);

          // Accelerometro X
          if(!_bias_computed){
            if(_calibration_samples < CALIBRATION_LIMIT){
              _bias_accel_x += ax_corrected;
              _calibration_samples++;
              _current_accel_x = 0.0;
            } else {
              _bias_accel_x /= (double)CALIBRATION_LIMIT;
              _bias_computed = true;
              std::cout << "IMU Calibrated with lever arm. Bias X: " << _bias_accel_x << std::endl;
            }
          } else {
            _current_accel_x = ax_corrected - _bias_accel_x;
            
        }


      }
      // aggiorna storico per la derivata
        _prev_gyro_x = gx_body;
        _prev_gyro_y = gy_body;
        _prev_gyro_z = gz_body;
        _prev_imu_timecode = _last_timecode;
        _first_imu_frame = false;
        _has_gyro = true;
        _has_imu = true;
      }   
    

    // RealSense
    

    if (in["message"]["pose"].contains("position") && in["message"]["pose"].contains("attitude")) {
      double raw_rs_x = 0.0, raw_rs_y = 0.0, raw_rs_theta = 0.0;
      //bool rs_found = false;
      auto& p = in["message"]["pose"];
        // Position
      //if (p.contains("position") && p.contains("attitude") && p["position"][0].is_array() && p["attitude"][0].is_array()) { //leave this for robustness in case of different formats
        // Check if it's [[x,y,z]] or [x,y,z]
        //if (p["position"][0].is_array()) {
          raw_rs_x = p["position"][0][0].get<double>();
          raw_rs_y = p["position"][0][1].get<double>();
        //}// else { // Capisci quale usi
        //  raw_rs_x = p["position"][0].get<double>();
        //  raw_rs_y = p["position"][1].get<double>();
        //}

        // Angle (Handle nested arrays)
      //if (p.contains("attitude")) {
        //if(p["attitude"][0].is_array()){
        raw_rs_theta = p["attitude"][0][2].get<double>();
        //} else { // Capisci quale usi
        //raw_rs_theta = p["attitude"][2].get<double>();
        //else raw_rs_theta = att.get<double>(); // If scalar
       // }
      //}
        //rs_found = true;
      //} //else{
        // return message error for format issue
        //_error = "RealSense pose format error.";
        //return return_type::error;
      //}
      
      
      
    


    // Anti-freeze check & filtering
    //if (rs_found) {

      double delta_input = raw_rs_theta - _last_input_rs_theta;

      //_last_input_rs_theta = raw_rs_theta;

      if(abs(delta_input) < 1e-6){ // semplicemente salta il dato se uguale al precedente
       // _filter_rs_x.clear(); //Non uso
       // _filter_rs_y.clear();//Non uso
       // _filter_rs_theta.clear();//Non uso
       // _first_rs_frame = true;
      } else {
        

      // TEST

      //double x_new = -raw_rs_x;
      //double y_new = -raw_rs_y;
      //double theta_new = raw_rs_theta;

      double correction_rad = 0.0; //Non uso
      double total_angle = _conf.rs_global_rotation + correction_rad;
      double cos_rs = cos(total_angle);
      double sin_rs = sin(total_angle);

      _rs_x = (raw_rs_x * cos_rs - raw_rs_y * sin_rs);
      _rs_y = (raw_rs_x * sin_rs + raw_rs_y * cos_rs);

      double theta_new = raw_rs_theta + total_angle;

      while(theta_new > M_PI) theta_new -= 2.0 * M_PI;
      while(theta_new < -M_PI) theta_new += 2.0 * M_PI;

      //ipotesi ruotato 180°
      //raw_rs_theta += M_PI;


      //raw_rs_theta = theta_new;
    

      // Sistema sinistrorso
      //raw_rs_y = -raw_rs_y;
      //raw_rs_x = -raw_rs_x;
      //raw_rs_theta = -raw_rs_theta;

      //double rot = _conf.rs_global_rotation;
      //double x_new = (raw_rs_x * cos(rot) - raw_rs_y * sin(rot));
      //double y_new = (raw_rs_x * sin(rot) + raw_rs_y * cos(rot));
      //double theta_new = raw_rs_theta + rot;

      //raw_rs_x = x_new;
      //raw_rs_y = y_new;
      //raw_rs_theta += rot;

      //if(_first_rs_frame){ //Non uso
      //_rs_theta_unwrapped = raw_rs_theta;
      //_prev_rs_theta_raw = raw_rs_theta;
      //_first_rs_frame = false;
     // }

      //double delta_theta_rs = raw_rs_theta - _prev_rs_theta_raw;

      //double delta_theta_rs = atan2(sin(theta_new - _prev_rs_theta_raw), cos(theta_new - _prev_rs_theta_raw));
      //_rs_theta_unwrapped += delta_theta_rs;

      //_rs_theta_unwrapped += delta_theta_rs;
      _prev_rs_theta_raw = theta_new;
      //raw_rs_theta = raw_rs_theta;

      _ekf_theta_rs = theta_new - M_PI;
      while(_ekf_theta_rs > M_PI) _ekf_theta_rs -= 2.0 * M_PI;
      while(_ekf_theta_rs < -M_PI) _ekf_theta_rs += 2.0 * M_PI;
    
      //_rs_x = _filter_rs_x.update(x_new);
      //_rs_y = _filter_rs_y.update(y_new);
      //_rs_theta = _filter_rs_theta.update(theta_new);
      _rs_theta = theta_new;
      
      _has_rs_update = true;
      _prev_raw_rs_x = _rs_x;
      _prev_raw_rs_y = _rs_y;
      _aruco_valid_for_vis = true;
      }
    }
  

    if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

  } catch (...){ return return_type::error; }
    return return_type::success;
  }
    


  // EKF Process
    return_type process(json &out) override {
        out.clear();

        // if no new data, skip
        if (!_has_new_encoder_data) {
            return return_type::success; // O warning,
        }

        double current_dt = _last_timecode - _prev_time;
        if(current_dt <= 0.01) return return_type::success; // Evita calcoli inutili

        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_encoder_data = false;

        double dt = current_dt;
        if (dt <= 1e-6) dt = 1e-6; // Prevenzione divisione per zero
        _prev_time = _last_timecode;

        // --- PREDICTION (Usa Gyroscope!) ---
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;
        double ds = (d_right + d_left) / 2.0;
        double ds_only_enc = ds;

        // calcolo velocità e accelerazione encoder
        double v_enc_raw = ds / dt;

        //_v_enc_smooth = _filter_enc_v.update(v_enc_raw); //Moving average logic


        double alpha_v = 0.10;
        _v_enc_smooth = (alpha_v * v_enc_raw) + ((1.0 - alpha_v) * _v_enc_smooth); // Low pass filter exponential

        double a_enc_raw = (_v_enc_smooth - _prev_v_enc) / dt;
        //_a_enc_smooth = _filter_enc_a.update(a_enc_raw); //Moving average logic 
        

        double alpha_a = 0.10;
        _a_enc_smooth = (alpha_a * a_enc_raw) + ((1.0 - alpha_a) * _a_enc_smooth); // Low pass filter exponential
        double a_enc_sma = _filter_enc_a.update(_a_enc_smooth); // Moving average filter
        _prev_v_enc = _v_enc_smooth;

        // manipolazione valori imu per inserire ritardo artificiale simile a encoder
        _imu_accel_smooth_ema1 = (alpha_v * _current_accel_x) + ((1.0 - alpha_v) * _imu_accel_smooth_ema1);
        _imu_accel_smooth_ema2 = (alpha_a * _imu_accel_smooth_ema1) + ((1.0 - alpha_a) * _imu_accel_smooth_ema2);
        double a_imu_final = _filter_accel.update(_imu_accel_smooth_ema2);
        //double a_imu_final= _imu_accel_smooth_ema2;
        //double a_imu_final = _current_accel_x;

        


        bool is_slipping = false;

        //double min_imu_accel_for_correction = 0.05;

        if(_conf.enable_slip_check && _bias_computed){
            // 2. Acceleration Mismatch (Burnout Check)
            // Se gli encoder dicono "Partenza a razzo" (alta accel)
            // Ma l'IMU dice "Movimento blando"
          

          if (abs(a_enc_sma) > abs(a_imu_final)){
            is_slipping = true; // Rilevato slip
            if(abs(a_imu_final) < _conf.min_imu_accel_for_correction){
              ds = _prev_ds;
            } else{
            double ratio = abs(a_enc_sma) / abs(a_imu_final);

            //if(ratio > 10) ratio = 10.0; // Limite massimo
            //SE ACCELERAZIONE ~0 DS = PREV_DS

            ds = ds / ratio;
            }
            _prev_ds = ds;
          }
          
        }

        _debug_slip.enc_accel = a_enc_sma;
        _debug_slip.imu_accel = a_imu_final;
        _debug_slip.is_slipping = is_slipping;

        
        // rotation encoder
        double d_theta_enc = (d_right - d_left) / _conf.baseline;
        // Rotation gyro
        double d_theta_gyro = 0.0;
        if(_has_gyro){
            d_theta_gyro = _current_gyro_z * dt;
        }

        //Fusione IMU/ENC
        double var_enc = _conf.sigma_enc_rot * _conf.sigma_enc_rot;
        double var_gyro = _conf.sigma_gyro * _conf.sigma_gyro;

        double weight_gyro = 0.0;
        double weight_enc = 1.0;
        if(_has_gyro){
            weight_gyro = var_enc / (var_enc + var_gyro);
            weight_enc = var_gyro / (var_enc + var_gyro);
        }

        double d_theta_fused = (d_theta_gyro * weight_gyro) + (d_theta_enc * weight_enc);

        // Calcolo varianze per update PXX
        double sigma_curr = is_slipping ? 0.25 : _conf.sigma_v; // Aumenta incertezza se slittamento
        double sigma_ds = sigma_curr * abs(ds) + 0.001; // Evita zero
        double combined_sigma = sqrt(pow(_conf.sigma_gyro * weight_gyro, 2) + pow(_conf.sigma_enc_rot * weight_enc, 2));
        double sigma_dtheta = combined_sigma * abs(d_theta_fused) + 0.001; // Evita zero

        ekf_predict(_state, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        ekf_predict(_state_partial, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        
        //Update Stati
        
        // Raw encoder only state - ODOMETRIA PURA
        double avg_theta_enc = _state_enc_only.theta + d_theta_enc / 2.0;
        _state_enc_only.x += ds_only_enc * cos(avg_theta_enc);
        _state_enc_only.y += ds_only_enc * sin(avg_theta_enc);
        _state_enc_only.theta = normalize_angle(_state_enc_only.theta + d_theta_enc);

        

        // ODOMETRIA + IMU 
        //double avg_theta_partial = _state_partial.x(2) + d_theta_fused / 2.0;
        //_state_partial.x(0) += ds * cos(avg_theta_partial);
        //_state_partial.x(1) += ds * sin(avg_theta_partial);
        //_state_partial.x(2) = normalize_angle(_state_partial.x(2) + d_theta_fused);

        // Correction
        if(_has_rs_update){
          est_rs_x = _rs_x + (cos(_rs_theta) * _conf.cam_offset_x - sin(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_x;
          est_rs_y = _rs_y + (sin(_rs_theta) * _conf.cam_offset_x + cos(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_y;
          
          Vector3d Z;
          Z << est_rs_x, est_rs_y, _ekf_theta_rs;

          Matrix3d R = Matrix3d::Zero();
          R(0, 0) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(1, 1) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(2, 2) = _conf.sigma_rs_ang * _conf.sigma_rs_ang;

          ekf_update(_state, Z, R);

          _has_rs_update = false;
        }

        _debug.theta_enc_only = d_theta_enc;
        _debug.theta_imu_only = d_theta_gyro;

        // OUTPUT

        

        // Odometry
        out["debug"]["raw_encoder_only"] = std::vector<double>{_state_enc_only.x, _state_enc_only.y, 0.0};

        // Partial EKF (odom + imu)
        out["debug"]["partial_ekf"] = std::vector<double>{_state_partial.x(0), _state_partial.x(1), 0.0};

        // Full EKF
        out["pose"]["position"] = std::vector<double>{_state.x(0), _state.x(1), 0.0};
        out["pose"]["orientation"] = _state.x(2);

        // Slip debug
        out["debug"]["accel_enc"] = _debug_slip.enc_accel;
        out["debug"]["accel_imu"] = _debug_slip.imu_accel;
        out["debug"]["is_slipping"] = _debug_slip.is_slipping ? 1.0 : 0.0;

        // Angles debug
        out["debug"]["theta_enc"] = _debug.theta_enc_only;
        out["debug"]["theta_imu"] = _debug.theta_imu_only;
        out["debug"]["angles"]["rs_raw"] = _prev_rs_theta_raw;
        out["debug"]["angles"]["rs_unwrapped"] = _rs_theta;
        out["debug"]["angles"]["fused"] = _state.x(2);
        out["debug"]["angles"]["enc_only"] = _state_enc_only.theta;
        out["debug"]["angles"]["ekf_rs"] = _ekf_theta_rs;

        //double theta_rs = _rs_theta_unwrapped;
        out["debug"]["rs_center"] = std::vector<double>{est_rs_x, est_rs_y, 0.0};
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timecode;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];

    if(p.contains("sigma_enc_lin")) _conf.sigma_enc_lin = p["sigma_enc_lin"];
    if(p.contains("sigma_enc_rot")) _conf.sigma_enc_rot = p["sigma_enc_rot"];
    if(p.contains("sigma_gyro")) _conf.sigma_gyro = p["sigma_gyro"];
    if(p.contains("sigma_rs_pos")) _conf.sigma_rs_pos = p["sigma_rs_pos"];
    if(p.contains("sigma_rs_ang")) _conf.sigma_rs_ang = p["sigma_rs_ang"];

    //if (p.contains("filter_window_rs")) { // probabilmente inutile
    //        _conf.filter_window_rs = p["filter_window_rs"];
    //        _filter_rs_x.resize(_conf.filter_window_rs);
    //        _filter_rs_y.resize(_conf.filter_window_rs);
    // }

    //if (p.contains("filter_window_imu")) { // probabilmente inutile
    //  _conf.filter_window_imu = p["filter_window_imu"];
    //  _filter_gyro.resize(_conf.filter_window_imu);
    //  _filter_accel.resize(_conf.filter_window_acc);
    //}

    

    if( p.contains("cam_offset_x")) _conf.cam_offset_x = p["cam_offset_x"];
    if( p.contains("cam_offset_y")) _conf.cam_offset_y = p["cam_offset_y"];
    if( p.contains("rs_global_rotation")) _conf.rs_global_rotation = p["rs_global_rotation"];
    if( p.contains("filter_window_imu")) _conf.filter_window_imu = p["filter_window_imu"];
    if( p.contains("filter_window_enc")) _conf.filter_window_enc = p["filter_window_enc"];
    //if( p.contains("invert_gyro")) _conf.invert_gyro = p["invert_gyro"];

    //if (p.contains("slip_accel_thresh")) _conf.slip_accel_thresh = p["slip_accel_thresh"];
    if (p.contains("min_imu_accel_for_correction")) _conf.min_imu_accel_for_correction = p["min_imu_accel_for_correction"];
    if (p.contains("enable_slip_check")) _conf.enable_slip_check = p["enable_slip_check"];
    if(p.contains("slip_accel_ratio")) _conf.slip_accel_ratio = p["slip_accel_ratio"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    
    _state.x = Vector3d::Zero();
    _state.P = Matrix3d::Identity() * 0.01; // Pic

    _state_partial.x = Vector3d::Zero();
    _state_partial.P = Matrix3d::Identity() * 0.01; //
    
    _state_enc_only = {0,0,0}; // Reset stato raw
    _debug = {0,0};
    _initialized = false;
    _prev_raw_rs_x = -9999.0;
    _prev_raw_rs_y = -9999.0;
    _first_rs_frame = true;
    _rs_theta_unwrapped = 0.0;
    _prev_rs_theta_raw = 0.0;
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  double _prev_rs_theta_raw = 0.0;
  double _rs_theta_unwrapped = 0.0;
  bool _first_rs_frame = true;

  double _last_input_rs_theta = 0.0;
  bool _aruco_valid_for_vis = false;

  double est_rs_x = 0.0;
  double est_rs_y = 0.0;
 
  

 //double raw_rs_theta = 0.0;


  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    in["encoders"]["left"] = 100;
    in["encoders"]["right"] = 100;
    
    f.load_data(in);
    f.process(out);

    std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}



