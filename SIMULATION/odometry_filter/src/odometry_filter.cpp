/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato interno del Robot (Pose)
    struct State {
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0; // Radianti
    } _state;

    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] (Esempio, da calibrare)
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;            // B [m]
        double ticks_per_rev = 4096.0;     // Risoluzione Encoder
    } _conf;

    // Variabili "buffer" per comunicare tra load_data e process
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;
    bool _has_new_data = false;
    string _last_agent_id = "";
    double _last_timestamp = 0.0;
    bool _has_timestamp = false;

    // Memoria per calcolo differenziale
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "RK2 Odometry Filter"},
            {"description", "Computes pose from encoders"}
        };
  }

  // --- FASE 1: RICEZIONE DATI 
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {
    bool found = false;
            // Cerchiamo gli encoder nel JSON in arrivo
            if (in.contains("/message/encoders/left") && in.contains("/message/encoders/right")) {
                _incoming_ticks_l = (long)in["/message/encoders/left"].get<double>();
                _incoming_ticks_r = (long)in["/message/encoders/right"].get<double>();
                found = true;
            } 
            else if (in.contains("encoders/left") && in.contains("encoders/right")) {
                _incoming_ticks_l = (long)in["/encoders/left"].get<double>();
                _incoming_ticks_r = (long)in["/encoders/right"].get<double>();
                found = true;
            } 
            else if(in.contains("message") && in["message"].contains("encoders")){
                _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
                _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
                found = true;
            }
            else if(in.contains("encoders")){
                _incoming_ticks_l = (long)in["encoders"]["left"].get<double>();
                _incoming_ticks_r = (long)in["encoders"]["right"].get<double>();
                found = true;
            }

            if(!found) return return_type::error; // No encoder data, skip

            _has_new_data = true;

            // Salviamo metadati se ci sono
            if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

            if(in.contains("message") && in["message"].contains("timecode") && in["message"]["timecode"].is_number()){
                auto& tc = in["message"]["timecode"];
                if(tc.is_number()) _last_timestamp = tc.get<double>();
            } else if (in.contains("/message/timecode") && in["/message/timecode"].is_number()) {
                _last_timestamp = in["/message/timecode"].get<double>();
            } else if (in.contains("timecode") && in["timecode"].is_number()) {
                    _last_timestamp = in["timecode"].get<double>();
            } 

    } catch (const std::exception &e) {
            return return_type::error;
        }
        return return_type::success;
  }

  // --- FASE 2: ELABORAZIONE E OUTPUT (Override obbligatorio) ---
    return_type process(json &out) override {
        out.clear();

        // Se non abbiamo ricevuto nuovi dati encoder, non calcoliamo nulla
        if (!_has_new_data) {
            return return_type::success; // O warning, dipende dalla logica
        }

        // 1. INIZIALIZZAZIONE (Primo avvio)
        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _initialized = true;
            _has_new_data = false; // Consumato
            return return_type::success;
        }

        // 2. CALCOLO DELTA
        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;

        // Aggiorniamo lo storico
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_data = false; // Dato consumato

        // 3. MODELLO CINEMATICO
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;

        double ds = (d_right + d_left) / 2.0;
        double d_alpha = (d_right - d_left) / _conf.baseline;

        // 4. INTEGRAZIONE RUNGE-KUTTA 2
        double avg_theta = _state.theta + (d_alpha / 2.0);
        
        _state.x += ds * cos(avg_theta);
        _state.y += ds * sin(avg_theta);
        _state.theta += d_alpha;

        // Normalizzazione Theta
        while (_state.theta > M_PI) _state.theta -= 2.0 * M_PI;
        while (_state.theta < -M_PI) _state.theta += 2.0 * M_PI;

        // 5. SCRITTURA OUTPUT
        out["pose"]["position"]["x"] = _state.x;
        out["pose"]["position"]["y"] = _state.y;
        out["pose"]["position"]["z"] = 0.0;
        out["pose"]["orientation"]["yaw"] = _state.theta;

        std::vector<double> pos_vec = {_state.x, _state.y, 0.0};
        out["pose_vector"] = pos_vec;
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timestamp;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    _state = {0, 0, 0};
    _initialized = false;
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    in["encoders"]["left"] = 100;
    in["encoders"]["right"] = 100;
    
    f.load_data(in);
    f.process(out);

    std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}